<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Softpanorama Bulletin Vol 26, No.1 (January, 2013)
Object-Oriented Cult</title>
<link rel="stylesheet" type="text/css" href="../../CSS/main.css">
</head>

<body>

<basefont face="Times" size="3">
<table border="0" width="100%" id="table1" height="135">
<tr>
<td rowspan="2" width="40%">

<p align="center"><font face="Bernard MT Condensed" color="#FF0000" size="7">
<a target="_blank" href="http://www.softpanorama.org/index.shtml"><font color="#FF0000">Softpanorama</font></a></font><b><br>
</b><i><b><font size="2">May the source be with you, but remember the KISS principle ;-)</font></b></i></p>
</td>
<td colspan="6" align="center" valign="bottom">
<form action="http://www.google.com/cse" id="cse-search-box">
<input type="hidden" name="cx" value="partner-pub-4031247137266443:ye0t3e-czf5" />
<input type="hidden" name="ie" value="ISO-8859-1" />
<input type="text" name="q" size="60" /> <input type="submit" name="sa" value="Search" />
<img src="http://www.google.com/images/poweredby_transparent/poweredby_999999.gif" alt="Google" />
</form>
</td>
</tr>
<tr>
<td bgcolor="#F5F5F5" align="center" width="9%"><b><a href="/switchboard.shtml">Contents</a></b></td>
<td bgcolor="#F5F5F5" align="center" width="7%"><b>
<a href="/bulletin.shtml">Bulletin</a></b></td>
<td bgcolor="#F5F5F5" align="center" width="16%"><b><font size="2">
<a href="/scriptorama.shtml">Scripting in shell and Perl</a></font></b></td>
<td bgcolor="#F5F5F5" align="center" width="10%"><b><font size="2">
<a href="/netorama.shtml">Network troubleshooting</a></font></b></td>
<td bgcolor="#F5F5F5" align="center" width="7%"><b><a href="/History/index.shtml">History</a></b></td>
<td bgcolor="#F5F5F5" align="center" width="7%"><b><a href="/Bulletin/Humor/index.shtml">Humor</a></b></td>
</tr>
</table>

<center>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- top_large_banner -->
<ins class="adsbygoogle"
     style="display:inline-block;width:970px;height:90px"
     data-ad-client="ca-pub-4031247137266443"
     data-ad-slot="9138796897"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
 </center>
<hr width="100%" noshade size="5" color="#FF0000">


<h1>Softpanorama Bulletin<br>
Vol 26, No.1 (January, 2013)</h1>

<p align="center"><b><a href="bulletin25_12.shtml">Prev</a> | <a href="index.shtml">Contents</a> |
Next</b></p>

<table border="1" bgcolor="#FFFFCC" id="table1" width="100%">
	<tr>
		<td align="center" width="9%" ><font size="2"><b><a href="../index.shtml">Bulletin</a></b></font></td>
		<td align="center" width="9%" ><b><a href="../Sp1998_v10/index.shtml">1998</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp1999_v11/index.shtml">1999</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2000_v12/index.shtml">2000</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2001_v13/index.shtml">2001</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2002_v14/index.shtml">2002</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2003_v15/index.shtml">2003</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2004_v16/index.shtml">2004</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2005_v17/index.shtml">2005</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2006_v18/index.shtml">2006</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2007_v19/index.shtml">2007</a></b></td>
	</tr>
	<tr>
		<td align="center" width="9%" ><b><a href="../Sp2008_v20/index.shtml">2008</a></b></td>
		<td align="center" width="10%" ><b><a href="../Sp2009_v21/index.shtml">2009</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2010_v22/index.shtml">2010</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2011_v23/index.shtml">2011</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2012_v24/index.shtml">2012</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2013_v25/index.shtml">2013</a></b></td>
		<td align="center" width="9%" ><b><a href="../Sp2014_v26/index.shtml">2014</a></b></td>
		<td align="center" width="9%" ><b>2015</b></td>
		<td align="center" width="9%" ><b>2016</b></td>
		<td align="center" width="9%" ><b>2017</b></td>
		<td align="center" width="9%" ><b>2018</b></td>
	</tr>
 
	<tr>
		<td align="center" width="9%" ><a href="bulletin25_01.shtml">Jan</a></td>
		<td align="center" width="9%" ><a href="bulletin25_02.shtml">Feb</a></td>
		<td align="center" width="9%" ><a href="bulletin25_03.shtml">Mar</a></td>
		<td align="center" width="9%" ><a href="bulletin25_04.shtml">Apr</a></td>
		<td align="center" width="9%" ><a href="bulletin25_05.shtml">May</a></td>
		<td align="center" width="9%" ><a href="bulletin25_06.shtml">Jun </a></td>
		<td align="center" width="9%" ><a href="bulletin25_07.shtml">Jul</a></td>
		<td align="center" width="9%" ><a href="bulletin25_09.shtml">Sept</a></td>
		<td align="center" width="9%" ><a href="bulletin25_10.shtml">Oct</a></td>
		<td align="center" width="9%" ><a href="bulletin25_11.shtml">Nov</a></td>
		<td align="center" width="10%" ><a href="bulletin25_12.shtml">Dec</a></td>
	</tr>
</table>

<h2>Object-Oriented Cult: A Slightly Skeptical View on the Object-Oriented Programming</h2>

<table border="0" width="100%" id="table1">
	<tr>
		<td>&nbsp;</td>
		<td width="70%">&quot;The great thing about Object Oriented code is that it can make small, simple 
		problems look like large, complex ones.&quot; <i><b>
		<a  target="_blank" href="http://www.linuxtoday.com/infrastructure/2010020700535OSHU">Top 50 Funny Computer Quotes</a></b></i><p>
		<b>cargo cult programming</b>: n. A style of (incompetent) programming dominated by ritual inclusion 
		of code or program structures that serve no real purpose. A cargo cult programmer will usually 
		explain the extra code as a way of working around some bug encountered in the past, but usually 
		neither the bug nor the reason the code apparently avoided the bug was ever fully understood 
		(compare
		<a target="_blank" href="http://www.science.uva.nl/~mes/jargon/s/shotgundebugging.html">shotgun 
		debugging</a>,
		<a target="_blank" href="http://www.science.uva.nl/~mes/jargon/v/voodooprogramming.html">voodoo 
		programming</a>). </p>

		<p>The term `cargo cult&#39; is a reference to aboriginal religions that grew up in the South Pacific 
		after World War II. The practices of these cults center on building elaborate mockups of airplanes 
		and military style landing strips in the hope of bringing the return of the god-like airplanes 
		that brought such marvelous cargo during the war. Hackish usage probably derives from Richard 
		Feynman&#39;s characterization of certain practices as &quot;cargo cult science&quot; in his book &quot;Surely 
		You&#39;re Joking, Mr. Feynman!&quot; (W. W. Norton &amp; Co, New York 1985, ISBN 0-393-01921-7).</p>

		<p align="right">
		<a target="_blank" href="http://www.science.uva.nl/~mes/jargon/c/cargocultprogramming.html">
		Jargon 4.2</a></p>

		<p align="left">Both communism and OOP rely on the concept of classes. Both generate a lot of 
		fanaticism and overuse this notion. That might be not an accident.</p>

		<p align="right"><a  target="_blank" href="http://beta.slashdot.org/story/15807">Slashdo</a>t</p>

		<p align="left">A data structure is a structure, not an object. Only if you exclusively use 
		the methods to manipulate the structure (via function pointers if you&#39;re using C) and each method 
		is implemented as co-routine, then you have an object. Such an approach is typically an overkill. 
		OO zealots make mistake typical for other zealots by insisting that it must be used for everywhere 
		and reject other useful approaches. This is religious zealotry. And please remember that Dark 
		Ages lasted several hundred years. <br>
&nbsp;</p>
		</td>
	</tr>
</table>

<div align="left">
<table border="0" width="178" height="620" align="right" cellspacing="4" bgcolor="#FFFFFF">
<tr><td>
<table border="1" width="174" height="616" align="center" bgcolor="#FF0000">
<tr><td>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Upper skyscaper -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-4031247137266443"
     data-ad-slot="0371843916"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</td></tr></table>
</td></tr></table>
</div>

<ul>

	<li><b><a name="Introduction" href="#Introduction">Introduction</a></b></li>

	<li><b><a href="#Limits_of_applicability">Limits of applicability</a></b></li>

	<li><b><a name="Introduction" href="#Cult-style_elements_in_OO">Cult-style elements in OO</a></b></li>

	<li><b><a href="#Hidden_typed_pointers:_plus_or_minus">Hidden typed pointers: plus or minus</a></b></li>

	<li><b><a href="#Coroutines">Coroutines</a></b></li>

	<li><b><a href="#Garbage_collection">Garbage collection and implementation of exceptions</a></b></li>

	<li><b>
	<a href="#Strict_hierarchical_layers_in_decomposition_of_program_into_modules_vs._Huffman_encoding_">
	Strict hierarchical layers in decomposition of program into modules vs. Huffman encoding</a></b></li>

	<li><b><a href="#OO_class-design_addiction_trap">OO class-design addiction trap</a></b></li>

	<li><b><a href="#Over-universalization">Over-universalization</a></b></li>

	<li><b><a href="#Shifting_sand">Shifting sand</a></b></li>

	<li><b><a href="#Cult-style_inability_to_discuss_alternative_methodologies">Cult-style inability 
	to discuss alternative methodologies</a></b><ul>

		<li><a href="#What_viable_alternatives_exist">What viable alternatives exist</a></li>

		<li><a href="#Dual_language_programming_methodology">&quot;Dual language&quot; programming methodology</a></li>

		<li><a href="#Defining_an_abstract_machine_or_even_specialized_language_for_the_problem">Defining 
		an abstract machine or even specialized language for the problem</a></li>

		<li>
		<a href="#Considering_input_data_as_a_language_and_structuring_application_as_a_compiler">Considering 
		input data as a language and structuring application as a compiler</a></li>

		<li><a href="#Virtual_appliances">Virtual appliances and usage of LAMP stack</a></li>
	</ul>
	</li>

	<li><b><a href="#Conclusion:_Object_Oriented_Programming_is_Oversold">Conclusion: Object Oriented 
	Programming is Oversold</a></b></li>
</ul>
<hr noshade color="#FF0000" width="33%" size="7">

<h3><a name="Introduction">Introduction</a></h3>

<p>I often wonder why object oriented programming (OO) is so popular, despite being a failure as a programming 
paradigm. Despite the fact that is rarely used in Web programming, which is the most dynamically developing 
application area (and many of those programs are based on LAMP stack with PHP as &quot;P&quot; in it).&nbsp; Is 
it becoming something that is talked about a lot, but rarely practiced? Just a topic artificially promoted 
for mercantile gains by&nbsp; &quot;<em>a hoard of practically illiterate and corrupt researchers publishing 
crap papers in junk conferences.</em>&quot; ? </p>

<p>To me it looks more like&nbsp; more dangerous development -- a variant of computer science
<a href="../../Skeptics/lysenkoism.shtml">Lysenkoism</a> (and I can attest that the current level of 
degradation of computer science&nbsp; can somewhat remind the level of degradation of social sciences 
under Stalin; it&#39;s now more about fashion then research with cloud computing as the latest hot fashion). 
If you read books considered to be &quot;OO classic&quot; the distinct impression that one gets is that &quot;king 
is naked&quot;.&nbsp;&nbsp; But if this is a variant of Lysenkoism absurdity of dogma&nbsp; does not matter 
and does not diminish the number of adherents. As universities are captured it has huge staying power 
despite of this.&nbsp; The same trick that is played in US universities with neoclassical economics.
</p>
<!---google box ------->
<table border="0" width="310" align="left" cellspacing="7" cellpadding="4">
<tr><td width="340" bgcolor="#FFFF00" valign="center" align="center">
<center>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Top Large Rectangle -->
<ins class="adsbygoogle"
     style="display:inline-block;width:336px;height:280px"
     data-ad-client="ca-pub-4031247137266443"
     data-ad-slot="3274064497"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></center>
</td></tr>
</table>
<!---end of google box ------->

<p>In the end, productivity and quality are the only true merits a programming methodology is to be 
judged upon. As Paul Graham noted the length of the program can serve as a useful (although far from 
perfect) metric for how much work is to write it. Not the length in characters, of course, but the length 
in distinct syntactic elements (tokens) -- basically, the number of lexical elements or, if you wish, 
the number of leafs in the parse tree. It may not be quite true that the shortest program requires the 
least effort to write, but in general length of program in lexical tokens correlates well with the complexity 
and the effort.&nbsp; OO approach fails in this metric as for language which permits structuring the 
program in both non-OO (procedural) and OO fashion (C++, Perl, etc) <font color="#FF0000"><i><b>&nbsp;program 
structured in OO fashion is typically longer. </b></i></font></p>

<p>Being extremely verbose (Java might be a king of verbosity among widely adopted languages; really 
the scion of Cobol ;-) is only one problem that negatively affects both the creation and, especially, 
maintenance of the programs.&nbsp; Java is definitely so verbose that this factor alone push down its 
level below, say, PL/1. And it&#39;s sad that PL/1 which was created in early 60th, is still competitive 
and superior to the language created 40 years later.&nbsp; Attempts to raise Java level using elaborate&nbsp; 
&quot;frameworks&quot; with complex sets of classes introduced other problems: bad performance and difficulties 
in debugging.&nbsp;&nbsp; </p>

<p>OO is a fuzzy concept, that has both good and bad sides. First of all it is often implemented in 
an incomplete, crippled way (C++, Java) which undermines its usefulness. To enjoy advantages of OO programming 
the language should provide allocation all the variables in the heap, <a href="#Coroutines">availability 
of coroutines</a>, correct implementation of exception handling,&nbsp; and
<a href="#Garbage_collection">garbage collection</a>. As such it is an expensive proposition (execution-wise).
</p>

<p>Also we should clearly state that OO-model does incorporate several good ideas:</p>
<ol>

	<li><b>The idea of equivalence between procedures and data structures.</b>&nbsp; Some &quot;OO&quot; languages 
	does not even include separate notion of data structures relying on one general mechanism.&nbsp; 
	This is probably a mistake, but you get the idea. </li>

	<li><b>Hierarchical partitioning of variables namespace into trees with &quot;inheritance&quot; as a pretty 
	neat method of accessing lower level data from higher level abstractions. </b>Somehow it reminds 
	me Unix filesystem structuring.&nbsp; This is what makes creation of large, complex systems simpler.&nbsp; 
	Or just possible. Without namespaces large program development requires iron variable naming discipline 
	that in the past only IBM was capable of. </li>

	<li><b>Usage of heap instead of stack for allocation of variables.</b> This was pioneered by PL/1. 
	So this 50 years old technique. Still dominance of C which was a system programming language (and 
	severely cut dialect of PL/1 used by Thompson and Richie in <a href="../../History/multix.shtml">
	Multics</a> as a system programming language) but somehow was used for application development was 
	unhealthy. Better and safer languages for application development are possible. And one feature 
	of such languages which time has come is allocation variable in heap and garbage collection.&nbsp; 
	Which probably explains why Java despite being so badly designed language managed to overtake Cobol.
	</li>

	<li><b>Naturalness of grouping of related procedures operating on the same data under &quot;one roof&quot;.&nbsp;
	</b>This was also pioneered by PL/1 with multi-entry procedures. This idea is also related to the 
	general equivalence of procedures and data structures which we mentioned before. It is just another 
	side of the same coin. </li>

	<li><b>Extension of the idea of type to structures and providing a mechanism of creating a new instance 
	of&nbsp; the structure with automatic population of necessary elements via special initializing 
	procedure called constructor. </b>&nbsp;Simula-67 was the inspiration but even before Simula-67 
	PL/1 invented the concept of creating similar structure from the base with the <tt>like</tt> operator. 
	Of course in OO this idea got a new sauce and new terminology, but compiler-writer wise this is 
	the same idea.&nbsp; Still it seems to me that JavaScript prototype-based approach might be superior. 
	See <a href="../../Scripting/Javascript/prototype_based_object_model.shtml">Prototype Based Object-Oriented 
	Programming</a> </li>
</ol>

<h3><a name="Limits_of_applicability">Limits of applicability</a></h3>

<p>While those good ideas shine in certain classes of programming tasks, such as GUI interfaces, there 
are programming tasks (for example computational) were they are useless or even harmful. When I see 
classic computer algorithms books polluted by OO nonsense, this is just a vivid reminder to me that 
Lysenkoism in computer science is still alive and thriving. And it serves as an indirect proof of pretty 
sad observation that in modern science at least one third of scientists are money seeking charlatans, 
while the other one third are intellectual prostitutes (actually among Professors of economics this 
proportion is even higher). Conversion of previously decent, honest researcher into one of those two 
despicable categories is not only possible, but <a href="../../Skeptics/index.shtml">happens quite often</a>. 
A lot of modern science is actually pseudoscience. Life in academia those days is very tough and often 
survival became the highest priority.&nbsp; Like somebody said &quot;Out of the crooked timber of humanity 
no straight thing was ever made&quot;. </p>

<p>But such a dominance of OO books devoted to description of algorithms is completely absurd, intellectually 
bankrupt way to explain algorithms to students. It is really terrifying in view that such books as
<a href="../../People/Knuth/index.shtml">Donald Knuth</a> masterpiece&nbsp; <i>
<a href="../../Bookshelf/Classic/taocp.shtml">The Art of Computer Programming</a></i> exists since 1968. 
OO do not replace, but complements procedural programming as not everything should be an object as some 
hot-headed OO enthusiasts (priests of this new techno cult) suggest.&nbsp; </p>

<p>Good design in not about following the latest hot fad, but about finding a unique set of tools and 
methods that make performing the task productive, or even possible. Kernighan &amp; Plauger long ago notes 
this fact in their still relevant book <a href="../../Bookshelf/Classic/teops.shtml">The Elements of 
Programming Style</a>: </p>
<blockquote>
	Good design and programming <em>is not learned by generalities</em>, but by seeing how significant 
	programs can be made clean, easy to read, easy to maintain and modify, human-engineered, efficient, 
	and reliable, by the application of good and programming practices. <em>Careful study and imitation 
	of good designs and programs significantly improves development skills.</em></blockquote>

<h3><a name="Cult-style_elements_in_OO">Cult-style elements in OO</a> </h3>

<table border="0" width="100%" id="table3">
	<tr>
		<td><br>
		</td>
		<td width="66%"><b><font size="1" face="Arial">&quot;The true faith compels us to believe there is 
		one holy Catholic Apostolic Church and this we firmly believe and plainly confess. And outside 
		of her there is no salvation or remission from sins.&quot;</font></b><p align="right"><b><i>
		<font size="1" face="Arial">- Boniface VII, Pope (1294-1303)</font></i></b></p>
		</td>
	</tr>
</table>

<p>Object-oriented programming (OOP) is often treated like a new Christianity and religious zeal of 
converts&nbsp; often borders with stupidity. And it definitely attracts numerous charlatans which propose 
magic cures like various object methodologies and, what is worse, write books about them&nbsp; ;-).
</p>

<p>All-in-all my impression is that for almost 30 years of its existence OO failed to improve programming 
productivity in comparison with alternative approaches, such as scripting languages (with some of them 
incorporating OO &quot;just in case&quot;&nbsp; to ride the fashion as you should never upset religious zealots 
;-).</p>

<p>If so this is more of a religious dogma, much like previously were structured programming and verification 
bonanza (with
<a target="_blank" href="http://www.cs.utexas.edu/users/UTCS/report/1994/profiles/dijkstra.html">Edger 
Dijkstra</a> as the first high priest&nbsp; of a modern computer science techno cult aka &quot;<i>church 
of&nbsp; computer scientology</i>&quot; ;-). And it is true that there are more corrupted academic fields 
then computer science, such as economics. </p>

<p>But still this is a really terrifying in a sense that it replicates Lysenkoism mentality on a new 
level with it&#39;s sycophants and self-reproducing cult mentality. And this cult mentality is a real problem. 
As <a  target="_blank" href="http://en.wikiquote.org/wiki/Peter_Kropotkin">Prince Kropotkin</a> used to say about prison 
guards in Alexandrov Central (one of most strict regime prisons in Tzar Russia) where he served his 
prison term &quot;<em>People are better then institutions</em>&quot;.&nbsp; </p>

<p>Like in any cult, high priests do not believe one bit in the nonsense they spread. For them it is 
just as the way for getting prestige and money. Just ask yourselves a question: in what place there 
were more sincere communists in, say, 1970th: in the Politburo of CPSU of the USSR or any small
<a  target="_blank" href="http://en.wikipedia.org/wiki/Monmartre">Montmartre </a>cafe. Like in all such cases, failure 
does not discourage rank and file members of the cult. Paradoxically it just increases the cult cohesion 
and zeal. </p>

<p>And in 2014 OO adepts are still brainwashing CS students despite the failure of OO provide advertised 
benefits for the last 25 years (Release 2.0 of C++ came in 1989). And they will continue just because 
this is very profitable economically. They do not care about
<a  target="_blank" href="http://en.wikipedia.org/wiki/Externality">negative externalities</a> (an economic term that 
is fully applicable in this case) connected with such a behavior. Just give me a Mercedes (or tenured 
position) now and f*ck the computer science future.&nbsp; </p>

<p>So far all this bloat and inefficiencies were covered by
<a  target="_blank" href="http://en.wikipedia.org/wiki/Moore's_law">Moore&#39;s law</a>. In other word you can claim any 
software development methodology highly successful because even if it is not, bloat and inefficiencies 
will be covered well by the tremendous growth of power of computers that is still continuing unabated, 
although slowed down a bit. </p>

<p>OO is a set of certain ideas which are not a panacea and as such never was and never will be a universally 
applicable programming paradigm. Object orientation has limited applicability and should be used when 
it brings distinct advantages, but not be pushed for everything like naive or crooked (mostly crooked 
and greedy) authors of &quot;Object Oriented Books&quot; (TM). </p>

<p>Here is the number of books&nbsp; of authors who wanted to milk the cow and included words &quot;object 
oriented&quot; in the title. Stats are for each year since 2000 (data are extracted from Library of Congress):</p>

<table border="1" width="100%" id="table31">
	<tr>
		<td align="center"><b>2000</b></td>
		<td align="center"><b>2001</b></td>
		<td align="center"><b>2002</b></td>
		<td align="center"><b>2003</b></td>
		<td align="center"><b>2004</b></td>
		<td align="center"><b>2005</b></td>
		<td align="center"><b>2006</b></td>
		<td align="center"><b>2007</b></td>
		<td align="center"><b>2008</b></td>
		<td align="center"><b>2009</b></td>
		<td align="center"><b>2010</b></td>
		<td align="center"><b>2011</b></td>
		<td align="center"><b>2012</b></td>
	</tr>
	<tr>
		<td align="center">92</td>
		<td align="center">83</td>
		<td align="center">104</td>
		<td align="center">76</td>
		<td align="center">69</td>
		<td align="center">70</td>
		<td align="center">76</td>
		<td align="center">68</td>
		<td align="center">57</td>
		<td align="center">60</td>
		<td align="center">61</td>
		<td align="center">46</td>
		<td align="center">27</td>
	</tr>
</table>

<p>So there are a lot of authors, who try to sell the latest fad to unsuspecting audience much like 
snake oil salesmen of the past.</p>

<p>I have strong personal hate for authors who wrote Object Oriented Algorithms and Data Structure books, 
and especially authors who convert previous procedure-oriented algorithms books into object-oriented 
attempting to earn fast buck; corruption is a real problem in academia, you should know that&nbsp; ;-).
</p>

<p><em>In a way, the term &quot;object oriented cult&quot; has a deeper meaning -- like in most cults high priests 
of the cult (including most &quot;object oriented&quot; books authors) really love only money and power.</em>&nbsp; 
And they do not believe in anything they preach... </p>
<center>

<table border="1" width="90%" bgcolor="#FFFF00" id="table30">
	<tr>
		<td><b><font size="2" face="Arial">In a way, the term &quot;object oriented cult&quot; has a deeper meaning 
		-- like in most cults high priests of the cult really love only money and power.&nbsp; And they 
		do not believe in anything they preach... </font></b></td>
	</tr>
</table>

</center>

<p>Many common applications can better be developed under different paradigms such as &quot;multi-pass processing&quot;, 
compiler like structure, abstract machine paradigm, functional language and so on.&nbsp; Just imagine 
that somebody tries to solve in object oriented way typical parsing of text string problem that can 
be solved with the regular expressions. Of course any sting is a derived object of alphabet of 26 letters 
but how far we will go with such &quot;OO approach&quot;. Or look at the poverty of books that sell object oriented 
approach to students who want to study algorithms and data structures. Those snake oil salesmen who 
wrote such books are using OO as a marketing trick to get a quick buck&nbsp; do not deserve the title 
of computer scientists and their degrees probably should be revoked ;-)&nbsp; Lord Tebbit once said 
&quot;You can judge a man by his enemies.&quot; Judging from the composition of pro-OO camp in computer science 
any alternative paradigm/methodology promoter or even skeptic like me looks good by definition ;-)</p>

<p>When I think about OO I see two distinct trends:</p>
<ul>

	<li>One is positive and is connected with the refinement of traditional programming constructs (generic 
	procedures, templates, hierarchical namespaces and controlled visibility of variables, etc.). The 
	hierarchical structuring of namespace and, to a certain extent, limited hierarchical namespace inheritance 
	is a very good idea and here OO languages added to the language design arsenal.&nbsp; In essence 
	OO blends concept of the procedure and data structure, providing each data structure with procedural 
	components and the way to initialize it using a special procedure called constructor. </li>

	<li>The second is hugely negative attempt to position OO as a new universal software engineering 
	paradigm. Often OO is oversold as panacea and even as a cult (<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/meyer1.htm">Bertrand 
	Meyer</a>). Ideally objects should be independent communicating entities, which means that programming 
	is accomplished by building structures and exchanging messages rather than by traditional procedural 
	way. For many (most?) problems forcing OO representation leads to a mismatch of the language used 
	to the problem domain. </li>
</ul>

<p>One should understand that OOP is an old hat and several OOP-based languages are 20 or more years 
old</p>

<p>OOP attempts to decompose the world into objects and claims that everything is an object. But saying 
that everything is an object not always provide an useful insight into the problem. Just think of sorting. 
Will it help to sort the file efficiently if you think that the records are objects. Most probably not. 
Things that have state and change their state are natural candidates to be represented as objects.&nbsp; 
Here are some guidelines to help decide if an object-oriented approach is appropriate: </p>
<ol>

	<li>Does your code manipulate a data structure that corresponds to a real-world object (such as 
	a window on the screen)? </li>

	<li>Is there a group of variables that you can group into structure processed by the same set of 
	functions? </li>

	<li>Is there a group of functions that can operate on a set of variables organized as structure?
	</li>
</ol>

<p>OOP emphases creation a set of classes as a universal method of decomposition of the problem.&nbsp; 
But in reality such a decomposition heavily depends on the set of data representation and algorithms 
that programmer knows and is comfortable with. That&#39;s why typical decomposition of the problem into 
classes by Unix programmer can be completely different (and often better) that decomposition of the 
same problem by Windows-only programmer. The essence of programming are algorithms operating on data 
structures and the &quot;programming culture&quot; used in particular OS exerts heavy influence on the way programmers 
think. In no way OO by itself can help you&nbsp; come up with optimal storage structures and algorithms 
for solving the problem. Moreover OO introduced entirely new and quite obscure terminology with the 
purpose of mystifying some old useful mechanisms of program structuring: </p>
<ul>

	<li>The binding of procedures to a data a structure (called object). Procedures pointers to which 
	are stored in the structure itself are now called methods. The ability to store a pointer to the 
	procedure in record field was available in languages since the early 60s (PL/1).</li>

	<li>The second concept is that of constructing a new data structure (called subclass) by extending 
	a given structure (the superclass). It&#39;s&nbsp; essentially a variation of&nbsp; <tt>like</tt> construct 
	introduced in PL/1.&nbsp; The cosmetics here is to consider any structure as a new type and use 
	type checking mechanism to prevent certain errors in manipulation of pointers to such structures. 
	In addition the process of creating a new instance is can be controlled with a hidden call to a 
	special procedure called constructor. </li>
</ul>

<p>Also while OO emphasize the concept of object (which can be abstracted as a coroutine with it sown 
state) in reality many so called OO languages does not implement the concept of coroutine. As such their 
methods do not have a real state, can&#39;t be suspended and resumed. In other words they are just new and 
slightly perverted way to use Algol-style procedures. As for paradigm shift, OO can be compared to introduction 
of a local LAN instead of mainframe. That mean that we now have a bunch of small, autonomous PCs each 
with own CPU, communicating with each other via messages over the net. It takes some imagination to 
see a simple procedure call as a real&nbsp; message passing mechanism -- only threads communicate through 
real messages. So true object model is intrinsically connected with multithreading, yet this connection 
is not understood well. True message mechanism presuppose that object (autonomous PC with its own CPU)&nbsp; 
was active before receiving it and will be active after processing it.&nbsp; To certain extent real 
OOP-style is a special case of concurrent programming.&nbsp;&nbsp; </p>

<h3><a name="Hidden_typed_pointers:_plus_or_minus">Hidden typed pointers: plus or minus</a>&nbsp;
</h3>

<p>Pointers are a great programming concept. But as any powerful feature it is a dangerous feature. 
OO tries to hide it removing explicit pointers from the language by hiding them and assigning them a 
type within the concept on instantiation of a class. Instance of the class is essentially a typed pointer, 
pointing to the memory area occupied by particular structure.&nbsp; </p>

<p>At the same time removing pointers from the language as first class elements is not without problems.&nbsp; 
It remove a lot of expressive power of the language. As Perl demonstrated quite convincingly presence 
of pointers in scripting language framework is very beneficial. Generally the idea that you need to 
switch to OO framework in order to use typed pointers in retrospect looks problematic.&nbsp; </p>

<p>And the idea of run-time accesses to elements of symbol table is a powerful one and can be expected 
far beyond the concept of typed pointes. For example Pl/1 style <tt>onsubscriptrange</tt> exception 
can be implemented this way. </p>

<h3><a name="Coroutines">Coroutines</a></h3>

<p>Co-routines are a necessary element of OO framework in were present in Simula 67 -- the ancestor 
of C++ and grandmother of all modern OO languages. If we assume that object need to have its own state 
that automatically imply that each method should have its own state too. </p>

<p>That means that OO languages that does not support the concept of coroutines are cripples that are 
missing fundamental feature of the OO model and should not generally be viewed as &quot;real&quot; OO languages.
</p>

<p>Implementation of exceptions without implementing methods as subroutines is always deficient. In 
essence the exception is nothing but stopped co-routine and that means that all regular methods in OO 
language that supports exception should be co-routines too and should allocate all variables on heap.</p>

<h3><a name="Garbage_collection">Garbage collection and implementation of exceptions</a></h3>

<p>&nbsp;Allocation all the variables on heap generally presuppose garbage collection. In this sense 
OO languages that does not support garbage collection are cripples.&nbsp; This list includes C++.&nbsp; 
Implementation of exceptions requires allocation all variable in the heap, as exception generally ruins 
stack and it needs to saved in the heap in any case.&nbsp; </p>

<h3>
<a name="Strict_hierarchical_layers_in_decomposition_of_program_into_modules_vs._Huffman_encoding_">
Strict hierarchical layers in decomposition of program into modules vs. Huffman encoding</a></h3>

<p>Decomposition of program into modules/classes is an art. OO tend to stimulate more strictly hierarchical 
(aka bureaucratic) decomposition. This is not the only type of decomposition possible or desirable. 
Sometimes much better way of decomposition in non-hierarchical decomposition when some frequently used 
operations are implemented outside hieratical structures as a shortcuts to typical sequences of operations. 
It is true that premature optimization is the root of all evils, but complete neglect those this aspect 
is also not good. OO programs with &quot;stupid decomposition&quot; tend to have unnecessary deep procedure nesting 
hierarchies during execution which not that good for modern CPUs with multistage execution pipelines 
and predictive execution.&nbsp;&nbsp;&nbsp; </p>

<h3><a name="OO_class-design_addiction_trap">OO class-design addiction trap</a></h3>

<p>Actually &quot;true OO&quot; is very similar to the idea of compiler-compiler as it tried to create some kind 
of abstract language (in a form of hierarchy of classes) that can help to solve particular problem and 
hopefully (often this is a false expectation)&nbsp; is reusable to others similar problems. But I think 
that more explicit approach of creating such an abstract language and a real compiler from it into some 
other &quot;target&quot; language can work better then OO. </p>

<p>Moreover there is a great danger in thinking just in term of hierarchy of classes well known to people 
who designed compilers. There is a great temptation to switch attention from the solving of the problem 
to the designing of a &quot;perfect&quot; set of classes. Instead of solving problem. Making them more elegant, 
more generic, more flexible. You name it. Often those refinement are not necessary for the particular 
problem and design became &quot;art for the sake of art&quot; -- completely detached from reality. </p>

<p>So the process of designing classes became self-perpetuating activity, disconnected with the task 
in hand (with usual justifications that this &quot;universal&quot; set of classes will help to design other problem 
later on the read, which never happens). The key point is that it became a very similar to addition 
and occupy lion share of developer time, which often dooms the problem he (or team) is trying to solve. 
I would call this effect OO class design addiction trap.</p>

<p>Moreover in a team of programmers there is often at least one member who psychologically is predisposed 
to this type of addiction (kind of&nbsp; and who instantly jump into opportunity disrupting the work 
of other members of the team with they constant desire to improve/change the set of classes used.&nbsp; 
Often such people as a wrong as they are fanatical and in the fanatical zeal they can do substantial 
damage to the team. </p>

<p>This &quot;class design addiction trap&quot; is very pronounced negative effect of OO, but people often try 
to hide it and never admit to it. </p>

<p>OO class-design addition trap has other side, which is well demonstrated itself in Java. People end 
with using so many class libraries that application slows down considerably and loading them at the 
beginning is a nuisance even of computers with SSD. Moreover subtle interactions between different versions 
introduce a very difficult to debug errors with each upgrade. </p>

<p>In other words usage of huge mass of Java class libraries increases complexity of a typical application 
program to the level when debugging becomes an art.&nbsp; And that often nullifies any savings on design 
and coding phases of program development. </p>

<h3><a name="Over-universalization">Over-universalization</a></h3>

<p>Rat race for the generalization/abstraction of the functionality of each and every class id a district 
danger that exist in OO programming. In the absence of better term let&#39;s call it &quot;Over-universalization&quot; 
and understand it as a distinct tendency to consider the most generic case in designing class libraries. 
It is a&nbsp; problem of programming as an art and the way of solving it often distinguish a master 
programmer from an average in a sense that master programmer knows were to stop. </p>

<p>But OO tend to make it more pronounced. But again the problem is universal in programming and exist 
in designing regular procedural subroutines libraries, for example glib. See, for example
<a href="../../OFM/Paradigm/Ch04/mc.shtml">History of development of Midnight Commander</a></p>

<p>This distinct tendency to make classes as abstract and as generic as possible makes them less suitable 
for&nbsp; the particular problem domain. If also increases the complexity of the design and maintenance. 
In other words it often backfires. In extreme cases the class library became so universal that it is 
not well applicable to <i>any case</i> where it can be useful and programmer start re-implementing those 
primitives&nbsp; again instead of using one from the class library.&nbsp; Such a paradox. </p>

<p>The same problem but to lesser extent happens with designers of libraries or modules for regular 
procedure languages or scripting languages that do not emphasize OO programming, such as Perl.&nbsp; 
You can definitely see it in <tt>cgi.pm</tt>. </p>

<p>The typical path of development reminds the proverb that the road to hell is paved with good intentions. 
I remember an example from my experience as a compiler writer. For example, initially the subroutine 
that output diagnostic messages to the screen and write them to the log is simple and useful. Then the 
second parameter is introduced and it became able to process and output message&nbsp; severity levels 
(terminal, server, error, warning, info, etc), then&nbsp; collection of statistics for all those levels 
is introduced, then it became able to expand macros, then to output context of the error, then ability 
to send messages above certain severity via SMTP is added, and then nobody is using it in the next project.&nbsp; 
Instead a simple subroutine that accepts a simple parameter (diagnostic message) is quickly written 
and the cycle of enhancements starts again with new players. </p>

<h3><a name="Shifting_sand">Shifting sand</a></h3>

<p>Programs rarely remain static, and invariably the original class structure becomes less useful with 
time. That results in more code being added as new classes, which undermines the conceptual integrity 
of the&nbsp; initial design and lead to &quot;class hell&quot;: the number of classes grows to the level when 
nobody can see the whole picture and due to this start reinventing the bicycle. </p>

<p>Moreover often the amount of class libraries grow to the level when just&nbsp; loading them at startup 
consumes considerable time making Java look very slow despite significant progress on JVM side. It looks 
like Gossling in his attempt to fix some problems with C++ badly missed
<a href="../../Scripting/Javascript/prototype_based_object_model.shtml">prototype-based programming</a> 
ideas, the ideas that found its way into JavaScript. In a recent blog entry he even mentioned: </p>
<blockquote>
	Over the years I&#39;ve used and created a wide variety of scripting languages, and in general, I&#39;m 
	a big fan of them. When the project that Java came out of first started, I was originally planning 
	to do a scripting language. But a number of forces pushed me away from that.
</blockquote>

<p align="right"><i>
<a target="_blank" href="http://blogs.sun.com/roller/page/jag?entry=radlab_scripting_and_scale">James 
Gosling</a>, Dec 15, 2005</i></p>

<p>When custom class library is used, there is another danger. When is already designed and working, 
people often see better ways to do something. And this temptation of introduce changes is almost irresistible. 
If not probably regulated it became like building on shifting sand. </p>

<p>Class library mess that exists in Java and that makes Java so vulnerable to exploits suggests that 
there should be better paradigms on modularizing OO program then Simula-67 style class model.&nbsp; 
In this sense <a href="../../Scripting/Javascript/prototype_based_object_model.shtml">prototype oriented 
OO model</a> probably deserves a second look. </p>

<h3><a name="Cult-style_inability_to_discuss_alternative_methodologies">Cult-style inability to discuss 
alternative methodologies</a></h3>

<p>One telling sign of a cult if unwillingness to discuss any alternatives. And true enough, the alternative 
methodologies are never discussed in OO books.&nbsp; As we are dealing with the techo-cult let&#39;s be 
realists and understand that as Niccolo Machiavelli observed </p>
<blockquote>

	<p>“And one should bear in mind that there is nothing more difficult to execute, nor more dubious 
	of success, nor more dangerous to administer than to introduce a new order to things; for he who 
	introduces it has all those who profit from the old order as his enemies; and he has only lukewarm 
	allies in all those who might profit from the new. This lukewarmness partly stems from fear of their 
	adversaries, who have the law on their side, and partly from the skepticism of men, who do not truly 
	believe in new things unless they have personal experience in them.” </p>
</blockquote>

<p>So it is often better to &quot;dilute&quot; or &quot;subvert&quot; OO development methodology then openly oppose it, 
especially if the company brass is hell bent on Java.&nbsp; Techo-cult adherents usually close ranks 
when they face a front attack.&nbsp; And as Paul Graham [<a  target="_blank" href="http://www.paulgraham.com/hundred.html">The 
Hundred-Year Language</a>]&nbsp; observed <font color="#FF0000"><i><b>&quot;It is irresistible to large organizations.&quot;
</b></i></font></p>

<p>That can be done in various creative ways so the discussion below provides just a few tips. All of 
them can be &quot;squeezed&quot; into compatibility with usage of some OO language (for example Python can be 
used instead of TCL in <a href="#Dual_language_programming_methodology">dual language programming</a> 
methodology),&nbsp; despite that each of them subverts the idea of OO in some fundamental way. </p>

<h3><a name="What_viable_alternatives_exist">What viable alternatives exist</a></h3>

<p>As a programming methodology OO programming competes with several other:</p>
<ul>

	<li><b><a href="#Dual_language_programming_methodology">Two level design methodologies using scripting 
	language + low level language like TCL+C</a>.&nbsp;&nbsp; </b></li>

	<li><b><a href="#Defining_an_abstract_machine_or_even_specialized_language_for_the_problem">Defining 
	an abstract machine or even specialized language for the problem</a></b></li>

	<li><b>
	<a href="#Considering_input_data_as_a_language_and_structuring_application_as_a_compiler">Considering 
	input data as a language and structuring application as a compiler</a></b></li>

	<li><b><a href="#Virtual_appliances">Virtual appliances and usage of LAMP stack</a></b></li>
</ul>

<h4 align="center"><b><a name="Dual_language_programming_methodology">&quot;Dual language&quot; programming methodology</a></b></h4>

<p>Using scripting language such as TCL and compiled language such as C in a single project has a lot 
of promise as it better separates <b><i>programming in the large (glue language)</i></b>, from <i>
<b>programming in the small (component programming)</b></i>. See also&nbsp; <i>
<a  target="_blank" href="http://en.wikipedia.org/wiki/Greenspun's_Tenth_Rule">Greenspun&#39;s Tenth Rule of Programming</a>.
</i>In a way this is a simple implementation of abstract machine with, say, C subroutines and scripting 
language library representing machine operations and scripting language as a glue (TCL for C). For many 
problems this <i>&quot;scripting language+compiling language&quot; </i>approach is a better paradigm of software 
development as access to the implementation of interpreter by C programmers enforced development discipline 
already developed and established in scripting interpreter development community. And <em>libraries 
used by interpreter usually are very high quality</em> and serve both as an example of how things would 
be done and for preventing &quot;reinventing the wheel&quot; --&nbsp; a tendency to re-implement parts of the 
library that are already implemented in any decent scripting interpreter.&nbsp; <em>Programmers are 
usually learn by example and code of even simple interpreter like AWK or gawk is a great school.</em>&nbsp; 
We can reformulate <a  target="_blank" href="http://en.wikipedia.org/wiki/Greenspun's_tenth_rule">Greenspun 10th law 
of programming</a>&nbsp; as following: </p>
<blockquote>
	Any sufficiently complicated OO program written in Java, C++ or other OO language&nbsp; contains 
	an ad hoc, informally-specified, bug-ridden, slow implementation of half of scripting language interpreter.</blockquote>

<p>As John Ousterhout <a target="_blank" href="http://www.vanderburg.org/Tcl/war/0009.html">aptly put 
it</a>: </p>
<blockquote>

	<p>I think that Stallman&#39;s objections to Tcl may stem largely from one aspect of Tcl&#39;s design that
	<i><b>he either doesn&#39;t understand or doesn&#39;t agree with. </b></i>This is the proposition that
	<i><b>you should use *two* languages for a large software system</b></i>: one, such as C or C++, 
	for manipulating the complex internal data structures where performance is key, and another, such 
	as Tcl, for writing small-ish scripts that tie together the C pieces and are used for extensions.
	<i><b>For the Tcl scripts, ease of learning, ease of programming and ease of glue-ing are more important 
	than performance or facilities for complex data structures and algorithms. </b></i>I think these 
	two programming environments are so different that it will be hard for a single language to work 
	well in both. For example, you don&#39;t see many people using C (or even Lisp) as a command language, 
	even though both of these languages work well for lower-level programming.</p>

	<p>Thus I designed Tcl to make it really easy to drop down into C or C++ when you come across tasks 
	that make more sense in a lower-level language. This way Tcl doesn&#39;t have to solve all of the world&#39;s 
	problems. <i><b>Stallman appears to prefer an approach where a single language is used for everything, 
	but I don&#39;t know of a successful instance of this approach.</b></i> Even Emacs uses substantial 
	amounts of C internally, no?</p>

	<p><i><b>I didn&#39;t design Tcl for building huge programs with 10&#39;s or 100&#39;s of thousands of lines 
	of Tcl</b></i>, and I&#39;ve been pretty surprised that people have used it for huge programs. <i>
	<b>What&#39;s even more surprising to me is that in some cases the resulting applications appear to 
	be manageable.</b></i> This certainly isn&#39;t what I intended the language for, but the results haven&#39;t 
	been as bad as I would have guessed.</p>
</blockquote>

<h4 align="center"><b>
<a name="Defining_an_abstract_machine_or_even_specialized_language_for_the_problem">Defining an abstract 
machine or even specialized language for the problem</a>&nbsp; </b></h4>

<p>This is approach is closely connected with the idea of structuring application as an abstract machine 
with well defined primitives (opcodes).&nbsp; If a full language is developed (which actually is not 
necessary)&nbsp; then this language does not need to produce object code. Compiling into a lower level 
language such as C, C++ or Java is a more viable approach. </p>

<p>In this case maintained of the application can be split into two distinct parts: maintenance of the 
higher level codebase and maintenance of the abstract machine that implements the higher level language 
and associated&nbsp; run time infrastructure. </p>

<p>The great advantage of this approach is that it allow to engage architects in actual programming 
which always lead to higher quality of final product: many primitives can be created from preexisting 
Unix utilities and programs and glued via shell language. See <a href="../../SE/architecture.shtml">
Real Insights into Architecture Come Only From Actual Programming </a></p>

<p>As the cost of programming is heaving dependent of the level of the language used, usage of the higher 
level language allow to dramatically lower the cost of the development. This approach also
<a href="../../SE/software_prototyping.shtml">stimulates prototyping</a> as often the first version 
of application can be glued from shell scripts and pre-existing Unix utilities and applications in a 
relatively short time which make the whole design process more manageable.&nbsp;&nbsp; </p>

<p>Even if the idea of defining the language will be thrown out later and another approach to development 
is adopted the positive effects of creating such a prototype can be felt for the rest of project development. 
In this sense &quot;Operate of higher level&quot; is not just an empty slogan. </p>

<h4 align="center">
<a name="Considering_input_data_as_a_language_and_structuring_application_as_a_compiler">Considering 
input data as a language and structuring application as a compiler</a></h4>

<p>Compilers stopped to be a &quot;black art&quot; in late 70th and this technology is greatly underutilized in 
modern software development.&nbsp; In this case you can catch some high level errors on syntactic level, 
which is impossible with OO although in many way it is similar &quot;compiler-compiler&quot; based methodology.&nbsp; 
In light-weight form the problem can be structures in compiler like form with distinct lexical analyzer, 
syntax analyzer and code generation parts.&nbsp; Multipass compiling with intermediate representation 
writable to disk is a great tool for solving complex problem and it naturally allow subsequent optimization 
converting read/write statements into coroutine interface. When intermediate representations between 
different passes are formally defined they also can be&nbsp; analyzed for correctness. Flexible switching 
between writing of intermediate files and coroutine linkage greatly simplifies debugging. XML can be 
used as a powerful intermediate representation language, although in many cases it is an overkill. Some 
derivative of SMTP message format is another commonly used representation.&nbsp; </p>

<h4 align="center"><b><a name="Virtual_appliances">Virtual appliances and usage of LAMP stack</a></b></h4>

<p>This is a the newest methodology, often based on LAMP, where the whole virtual instance of OS become 
a part of application and&nbsp; application uses OS logging, OS scheduler, etc instead of reinventing 
the bicycle.&nbsp; This is a new a promising approach to programming substantial class of problems. 
This specialized virtual machine provides services via network interface, for example Web interface. 
LAMP stack which can be used in this approach proved to be a tremendously useful development paradigm.&nbsp; 
And in most cases non-OO languages are used in P part of this acronym. But Python and Ruby has well 
implement OO features, so this approach does not completely exclude usage of OO where is can really 
beneficial and not dictated by <a href="../../Skeptics/groupthink.shtml">groupthink</a> or fashion.
</p>

<p>One important advantage of this approach is the executables in any OS are much more like objects 
that classes with methods in modern OO languages. They definitely have their state, can be interrupted 
and resumed and communicate with other executable via messages (which includes sockets).&nbsp; So OS 
infrastructure in general can be viewed as object oriented environment &quot;in the large&quot; while all OO languages 
belong to OO in the small.&nbsp;&nbsp; </p>

<h3><a name="Conclusion:_Object_Oriented_Programming_is_Oversold">Conclusion: Object Oriented Programming 
is Oversold</a></h3>

<p>In his paper <a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/oopbad.htm">
Object Oriented Programming Oversold!</a> B. Jacobs&nbsp; aptly noted: </p>
<blockquote>
	<b><i>OOP became popular primarily because of GUI interfaces.</i></b> In fact, many non-programmers 
	think that &quot;Object&quot; in OOP means a screen object such as a button, icon, or listbox. They often 
	talk about drag-and-drop &quot;objects&quot;. <font color="#FF0000"><b><i>GUI&#39;s sold products. Anything associated 
	with GUI&#39;s was sure to get market and sales brochure attention, regardless of whether this association 
	was accurate or not. </i></b></font>I have even seen salary surveys from respected survey companies 
	that have a programming classification called &quot;GUI/OOP Programming&quot;.

	<p><b><i>Screen objects can correspond closely with OOP objects, making them allegedly easier to 
	manipulate in a program. We do not disagree that OOP works fairly well for GUI&#39;s,
	<font color="#FF0000">but it is now being sold as the solve-all and be-all of programming.</font></i></b><font color="#FF0000">
	</font></p>

	<p>Some argue that OOP is still important even if not dealing directly with GUI&#39;s. <b><i>In our 
	opinion, much of the hype about OOP is faddish. OOP in itself does NOT allow programs to do things 
	that they could not do before. <font color="#FF0000">OOP is more of a program organizational philosophy 
	rather than a set of new external solutions or operations.</font></i></b> </p>
</blockquote>

<p>He also provided a deep insight that attractiveness of OO is somewhat similar to the attractiveness 
of the social doctrine like communism (with its ideas of central hierarchical planning model and idealistic 
hopes that that will eliminate wasteful, redundant procedures). Actually the idea that both OO and Marxism 
overemphasized classes is pretty cute :-).&nbsp;&nbsp; As well as the idea that full hierarchical decomposition 
is a close analogy to bureaucracy that is making organizations so dysfunctional: </p>
<blockquote>

	<p><font size="2" face="Arial">Unfortunately, OOP and economic communism suffer similar problems.
	<b><i>They both get bogged down in their own bureaucracy and have a difficult time dealing with 
	change and outside influences which are not a part of the internal bureaucracy. </i></b>For example, 
	a process may be stuck in department X because it may be missing a piece of information that the 
	next department, Y, or later departments may not even need. Department X may not know or care that 
	the waiting piece of information is <b>not</b> needed by later departments. <b><i>It simply has 
	it&#39;s rules and regulations and follows them like a good little bureaucratic soldier.</i></b></font></p>
</blockquote>

<p>This analogy can well look stretched, but highly placed &quot;<i>object oriented jerks</i>&quot; from academia 
really remind me high priests of Marxism-Leninism in at least in one aspect -- complete personal corruption.
</p>

<p>In his old Usenix paper
<a target="_blank" href="http://www.usenix.org/publications/library/proceedings/sf94/johnson.html">Objecting 
To Objects</a> Stephen C. Johnson wrote</p>
<blockquote>

	<p><font size="2" face="Arial"><b><i>Object-oriented programming (OOP) is an ancient (25-year-old) 
	technology, now being pushed as the answer to all the world&#39;s programming ills. </i></b>While not 
	denying that there are advantages to OOP,<i><b><font color="#FF0000"> I argue that it is being oversold.
	</font></b></i>In particular, OOP gives little support to GUI and network support, some of the biggest 
	software problems we face today. <font color="#FF0000"><i><b>It is difficult to constrain relationships 
	between objects</b></i></font> (something SmallTalk did better than C++). Fundamentally, object 
	reuse has much more to do with the underlying models being supported than with the &quot;objectness&quot; 
	of the programming language. <b><i><font color="#FF0000">Object-oriented languages tend to burn 
	CPU cycles, both at compile and execution time, out of proportion to the benefits they provide</font>.</i></b> 
	In summary, <i><b>the goods things about OOP are often the information hiding and consistent underlying 
	models which derive from clean thoughts, not linguistic cliches.</b></i></font></p>
</blockquote>

<p>In his April 2003 Keynote for PyCon2003) Paul Graham suggested [<a  target="_blank" href="http://www.paulgraham.com/hundred.html">The 
Hundred-Year Language</a>] : </p>
<blockquote>

	<p><font face="verdana">...<em></font>Somehow the idea of reusability got attached to object-oriented 
	programming in the 1980s, and no amount of evidence to the contrary seems to be able to shake it 
	free.</em> But although some object-oriented software is reusable, what makes it reusable is its 
	bottom-upness, not its object-orientedness. </p>

	<p>Consider libraries: they&#39;re reusable because they&#39;re language, whether they&#39;re written in an 
	object-oriented style or not.</p>

	<p><font color="#FF0000"><i><b>I don&#39;t predict the demise of object-oriented programming, by the 
	way. Though I don&#39;t think it has much to offer good programmers, except in certain specialized domains, 
	it is irresistible to large organizations. Object-oriented programming offers a sustainable way 
	to write spaghetti code. It lets you accrete programs as a series of patches. </p>

	<p>Large organizations always tend to develop software this way, and I expect this to be as true 
	in a hundred years as it is today.</b></i></font></p>

	<p>...One helpful trick here is to use the <a  target="_blank" href="http://www.paulgraham.com/power.html">length</a> 
	of the program as an approximation for how much work it is to write. Not the length in characters, 
	of course, but the length in distinct syntactic elements-- basically, the size of the parse tree.
	<font color="#FF0000"><i><b>It may not be quite true that the shortest program is the least work 
	to write, but it&#39;s close enough that you&#39;re better off aiming for the solid target of brevity than 
	the fuzzy, nearby one of least work.</b></i></font> Then the algorithm for language design becomes: 
	look at a program and ask, is there any way to write this that&#39;s shorter?</p>
</blockquote>

<p align="right"><i>Dr. Nikolai Bezroukov</i></p>

<p align="left"><i><b>P.S. Newer version of the paper might be available at
<a href="../../SE/anti_oo.shtml">Object-Oriented Cult: A Slightly Skeptical View on the 
Object-Oriented Programming</a></b></i></p>
<hr>
<table border="1" width="100%"><tr><td width="100%" align="center"  colspan="2">
<center><b>Top updates</b></center>
<center>
<script type="text/javascript">
<!--google_ad_client = "ca-pub-4031247137266443";
/* 728x15, created 8/7/09 */
google_ad_slot = "5138458259";
google_ad_width = 728;
google_ad_height = 15;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</center>
<iframe src="/topupdates.shtml" width="100%" height="300"><p>Your browser does not support iframes.</p>
</iframe>
<hr>
</td><tr><td width="29%" align="center" bgcolor="#C0C0C0">
<a href="switchboard.shtml">Softpanorama Switchboard</a></td><td width="69%" bgcolor="#C0C0C0">

<center>
   <form action="http://www.google.com" id="cse-search-box">
         <div>
            <input type="hidden" name="cx" value="partner-pub-4031247137266443:1521064891" />
            <input type="hidden" name="ie" value="UTF-8" /><input type="text" name="q" size="55" />
            <input type="submit" name="sa" value="Search" />
         </div>
      </form>
      <script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&lang=en"></script>
      <b><font size="2">Softpanorama Search </font></b>
</center>
</tr>
</table>
</td></tr></table>
<hr noshade color="#FF0000" size="5">




<hr>

<h2><a name="NEWS_TOC">NEWS CONTENTS</a></h2>
<ul>
<li><a href="#n2012_1215_stroustrup_on__next_gen_c_i_didnt_want_to_let_go_of_my_baby">Stroustrup on  next-gen C++ I didn&#39;t want to let go of my baby</a>
<li><a href="#n2012_1201_a_programmer’s__discussion_procedural_vs_oo">A Programmer’s  Discussion Procedural vs. OO</a>
<li><a href="#n2012_0731_your__code_oop_or_poo">Your  Code: OOP or POO?</a>
<li><a href="#n2011_0907_object_oriented_programming__is_inherently_harmful">Object Oriented Programming  is Inherently Harmful</a>
<li><a href="#n2011_0830_hope_for_multi_language_programming">Hope For Multi-Language Programming</a>
<li><a href="#n2011_0306_object_oriented_programming__is_inherently_harmful">Object Oriented Programming  is Inherently Harmful</a>
<li><a href="#n2010_1213_skeptical_quotes_about_oo_programming_and_languages"> Skeptical quotes about OO programming and languages</a>
<li><a href="#n2009_1010_the_new__software_crisis">The new  software crisis </a>
<li><a href="#n2008_0228_objecting__to_objects_by_stephen_c_johnson">Objecting  to Objects, by Stephen C. Johnson</a>
<li><a href="#n2007_0926_will_ruby_kill_php">Will Ruby kill PHP</a>
<li><a href="#n2007_0307_coding_horror_your__code_oop_or_poo">Coding Horror Your  Code OOP or POO</a>
<li><a href="#n2007_0507_the_hundred_year_language">The Hundred-Year Language</a>
<li><a href="#n2007_0501_subtyping_subclassing_and__trouble_with_oop">Subtyping, Subclassing, and  Trouble with OOP</a>
<li><a href="#n2006_1215_the__mythical_open_source_miracle">The  mythical open source miracle</a>
<li><a href="#n2006_0924_dreamsongs_essays__downloads">Dreamsongs Essays  Downloads</a>
<li><a href="#n2006_0924_objects_have_failed">Objects Have Failed</a>
<li><a href="#n2006_0214_oop_criticism">OOP Criticism</a>
<li><a href="#n2006_0214_cargo_cult_software_engineering"> Cargo Cult Software Engineering</a>
<li><a href="#n2006_0214_incipient_thoughts__throw_some_java_salt_over_your_shoulder">Incipient(thoughts)  Throw some Java salt over your shoulder</a>
<li><a href="#n2004_1115_smalltalk_tidbits_industry_rants_cargo_cult_coding_practices"> Smalltalk Tidbits, Industry Rants cargo cult coding practices</a>
<li><a href="#n2000_00_november_15_2004_19_23_32__est"> November 15, 2004 19:23:32  	EST</font></a>
<li><a href="#n2000_00_november_16_2004_10_08_33__est"> November 16, 2004 10:08:33  	EST</font></a>
<li><a href="#n2000_00_cargo_cults__in_java">Cargo Cults  in Java</a>
<li><a href="#n2000_00_beware_of_cargo_cult__coding">Beware of &#39;Cargo Cult&#39;  Coding</a>
<li><a href="#n2000_00_so_much_oo__so_little_reuse">&nbsp;So Much OO,  So Little Reuse</a>
<li><a href="#n2000_00_">&nbsp;</a>
<li><a href="#n2000_00_the_object_oriented__hype">The Object Oriented  Hype</a>
<li><a href="#n2000_00_bad_engineering_properties_of_object_oriented_language"> Bad Engineering Properties of Object-Oriented Language</a>
<li><a href="#n2000_00_oop_criticism">OOP Criticism</a>
<li><a href="#n2000_00_external_links"><font size="2">External Links</font></a>
<li><a href="#n2000_00_critique_of_the_object_oriented__paradigm_beyond_object_orientation">Critique of the Object Oriented  Paradigm: Beyond Object-Orientation</a>
</ul>
<h2 align="center"><a name="News">Old News</a> ;-)</h2>

<table border="0" width="100%">
	<tr>
		<td rowspan="2">&nbsp;</td>
		<td width="66%">Object Oriented Programming (OOP) <font color="#FF0000"><i><b>is currently being 
		hyped as the best way to do everything from promoting code reuse to forming lasting relationships 
		with persons of your preferred sexual orientation.</b></i></font> This paper tries to demystify 
		the benefits of OOP. We point out that, as with so many previous software engineering fads, 
		the biggest gains in using OOP result from applying principles that are older than, and largely 
		independent of, OOP. Moreover, many of the claimed benefits are either not true or true only 
		by chance, while occasioning some high costs that are rarely discussed. Most seriously, all 
		the hype is preventing progress in tackling problems that are both more important and harder: 
		control of parallel and distributed applications, GUI design and implementation, fault tolerant 
		and real-time programming. OOP has little to offer these areas. Fundamentally, you get good 
		software by thinking about it, designing it well, implementing it carefully, and testing it 
		intelligently, not by mindlessly using an expensive mechanical process.

		<p align="right"><i>-- Abstract to
		<a  target="_blank" href="http://www.usenix.org/publications/library/proceedings/sf94/full_papers/johnson.html">
		Objecting to Objects, by Stephen C. Johnson, </a><br>
		<a  target="_blank" href="http://www.usenix.org/publications/library/proceedings/sf94/full_papers/johnson.html">
		Melismatic Software</a></i></p>
		</td>
	</tr>
	<tr>
		<td width="66%">

		<p align="left">The road to Hell is paved with good intentions.</p>

		<p align="right"><i>-- Proverb</i></p>
		</td>
	</tr>
</table>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#NEWS_TOC"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2012_1215_stroustrup_on__next_gen_c_i_didnt_want_to_let_go_of_my_baby" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2012_1201_a_programmer’s__discussion_procedural_vs_oo"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Dec 15, 2012]
<a  target="_blank" href="http://www.theregister.co.uk/2012/12/13/stroustrup_on_c_plus_plus/page2.html">Stroustrup on 
next-gen C++ I didn&#39;t want to let go of my baby</a></h4>
<blockquote>

	<h6><a  target="_blank" href="http://www.theregister.co.uk/2012/12/13/stroustrup_on_c_plus_plus/page2.html">The Register</a></h6>

	<p>So what are programmers doing wrong?<font color="#FF0000"><i><b> One thing is too much use of 
	inheritance.</b></i></font> &quot;It is obviously hugely overused,&quot; he says. &quot;There are languages where 
	you can’t express yourself without inheritance - they fit everything into a hierarchy and it doesn’t 
	make any sense. Inheritance should come from the domain, from the problem. It is good where there 
	is an &#39;is a&#39; or &#39;kind of&#39; relationship in the fundamental domain. Shapes fit into this, there is 
	something natural there. Similarly device controllers have natural hierarchies that you should exploit. 
	If you forget about programming languages and look at the application domain, the questions about 
	deep or shallow inheritance answer themselves.</p>

	<p>He also takes care to distinguish &quot;<i>implementation</i> inheritance, where in some sense you 
	want a deep hierarchies so that most of the implementation is shared, and <i>interface</i> inheritance 
	- where you don’t care, all you want to do is to hide a set of implementations behind a common interface. 
	I don’t think people distinguish that enough.&quot;</p>

	<p>Another bugbear is protected visibility. &quot;When you build big hierarchies you get two kinds of 
	users [of the classes]: the general users, and the people who extend the hierarchy. People who extend 
	the hierarchy often need protected access. <font color="#FF0000"><i><b>The reason I like public 
	or private is that if it is private, nobody can mess with it.</b></i></font></p>

	<p>&quot;If I say protected, about some data, anybody can mess with it and scramble my data. That has 
	been a problem. <font color="#FF0000"><i><b>It is not such a problem if the protected interface 
	really is functional, a set of functions that you have provided as support for implementers of new 
	classes...</b></i></font> The ideal is public or private, and sometimes out of necessity we use 
	protected,” he said.</p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2012_1215_stroustrup_on__next_gen_c_i_didnt_want_to_let_go_of_my_baby"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2012_1201_a_programmer’s__discussion_procedural_vs_oo" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2012_0731_your__code_oop_or_poo"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Dec 01, 2012]
<a  target="_blank" href="http://www.linuxjournal.com/content/programmer’s-discussion-procedural-vs-oo">A Programmer’s 
Discussion Procedural vs. OO</a></h4>

<h5>The division between OO and procedural is but a hair&#39;s breadth compared to that between those who 
understand pointers and those that do not.</h5>
<blockquote>

	<h6><a  target="_blank" href="http://www.linuxjournal.com/content/programmer’s-discussion-procedural-vs-oo">Linux 
	Journal</a></h6>

	<p><b>
	<a  target="_blank" href="http://www.linuxjournal.com/content/programmer’s-discussion-procedural-vs-oo#comment-355647">
	Surprise: Ancient advocacy alive :)</a> </b>&nbsp;</p>

	<p>Gene , 09/07/2010 - 03:32. </p>
	<blockquote>
		Can not help my desire to say a couple of words. My coding experience is 25+ years.
		<font color="#FF0000"><i><b>And OOP never was attractive to me. Probably, that was due to I 
		always had what OOP could give, thanks to Modula-2 and Oberon-2.</b></i></font><p>Philosophy 
		aside, coding OOP practice I happened to observe was that OOP provided means mainly for</p>
		<ol>

			<li>Modularisation (encapsulation).</li>

			<li>Making reusable code libraries.</li>
		</ol>

		<p>IMHO that was the reason of OOP success and that was all what PP could give by means of modules.</p>

		<p>Now it is time to recall that (celebarted) OOP method is to create a number of objects and 
		to fire up their interaction by message exchange. </p>

		<p><font color="#FF0000"><i><b>Regarding its methodology, OOP approach seems to be much more 
		obscure than PP.</b></i></font> May be, that is due to the fact that it is much more natural 
		for human being to invent an algorithm for a purpose, than to build an abstract machine which 
		would work according to some model in a way that it would implement an algorithm for a purpose...</p>

		<p><font color="#FF0000"><i><b>AFAIC the only domain of OOP methaphor to fit more or less nicely 
		is windowed GUI (interactive graphics) and modelling of automation systems blocks.</b></i></font></p>

		<p>Regards,<br>
		Gene</p>
	</blockquote>
	<b>
	<a  target="_blank" href="http://www.linuxjournal.com/content/programmer’s-discussion-procedural-vs-oo#comment-355499">
	modularity vs. OOP</a> </b>&nbsp;<p><b>vova,</b> Wed, 09/01/2010 - 17:11. </p>
	<blockquote>
		OOP is an abstraction made up of too many false hopes, thus counterproductive as 99% people 
		see it now ;)<p>Here we are, real life example: every comment in this thread [from OO point 
		of view] is derived class of 26 ASCII letters, but, how useful such abstraction is for the matter?</p>

		<p>Larry Well had classic example somewhere: radio tower and plumbing pipe are made from single 
		base class, but they have almost nothing in common. </p>

		<p>Classes hierarchy,...</p>

		<p>Vertical inheritance paradigm clearly becomes insufficient,.. then horizontal (aka transparent) 
		inheritance comes into play, making a mess from the ideal initial picture. (forgive me to ask,.. 
		does java has it?.. perl does, but,..)</p>

		<p>Isolation,.. Students are getting wrong idea about it, listening fairy OOP tales. They start 
		to believe that object&#39;s properties becomes invisible when someone&#39;s eyes get closed.</p>

		<p>Instead learning about modularity, decomposition, protocols, state machines, a code re-use,.. 
		every and any OO writer most of life reinvents the wheel cloning a classes and methods from 
		zillion similar ones.</p>

		<p>Result is: almost every OOP product is looking as collection of procedures, thus being near 
		imposible for lock-free threading.</p>

		<p>I vote for data-driven modular design, -- back to the nature, to stop lie to ourselve.</p>

		<p>OOP as scientific abstraction is fine... and limited. </p>
	</blockquote>

	<p><b>Gordon J Milne</b> <b>
	<a  target="_blank" href="http://www.linuxjournal.com/content/programmer’s-discussion-procedural-vs-oo#comment-355541">
	Some might not be able to</a> </b>&nbsp;09/02/2010 - 16:02. </p>
	<blockquote>
		<font color="#FF0000"><i><b>Some might not be able to grasp OO but this is a small number compared 
		to the number of people who just cannot understand pointers. For a great many people pointers 
		remain magical.</b></i></font><p>Joel has a great article (<a title="http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html" href="http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html">http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html</a>) 
		on this.</p>

		<p><font color="#FF0000"><i><b>The division between OO and procedural is but a hair&#39;s breadth 
		compared to that between those who understand pointers and those that do not.</b></i></font></p>
	</blockquote>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2012_1201_a_programmer’s__discussion_procedural_vs_oo"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2012_0731_your__code_oop_or_poo" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2011_0907_object_oriented_programming__is_inherently_harmful"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Jul 31, 2012] <a  target="_blank" href="http://www.codinghorror.com/blog/2007/03/your-code-oop-or-poo.html">Your 
Code: OOP or POO?</a></h4>

<h5>POO - Poorly Organized Objects ? Clarity is the king in programming ! Hierarchy is not. </h5>
<blockquote>

	<p>I&#39;m not a fan of <font color="#FF0000"><i><b>object orientation for the sake of object orientation.</b></i></font> 
	Often the proper OO way of doing things ends up being
	<a  target="_blank" href="http://www.codinghorror.com/blog/archives/000617.html">a productivity tax</a>. Sure, objects 
	are the backbone of any modern programming language, but sometimes I can&#39;t help feeling that
	<a  target="_blank" href="http://www.codinghorror.com/blog/archives/000033.html">slavish adherence to objects is 
	making my life a lot more difficult</a>. I&#39;ve always found
	<a  target="_blank" href="http://www.codinghorror.com/blog/archives/000042.html">inheritance hierarchies to be brittle 
	and unstable</a>, and then there&#39;s the massive
	<a  target="_blank" href="http://www.codinghorror.com/blog/archives/000621.html">object-relational divide</a> to 
	contend with. OO seems to bring at least as many problems to the table as it solves. </p>

	<p>Perhaps Paul Graham <a  target="_blank" href="http://www.paulgraham.com/noop.html">summarized it best</a>: </p>
	<blockquote>
		<font color="#FF0000"><i><b>Object-oriented programming generates a lot of what looks like work.</b></i></font> 
		Back in the days of fanfold, there was a type of programmer who would only put five or ten lines 
		of code on a page, preceded by twenty lines of elaborately formatted comments.

		<p>Object-oriented programming is like crack for these people: it lets you incorporate all this 
		scaffolding right into your source code. </p>

		<p><font color="#FF0000"><i><b>Something that a Lisp hacker might handle by pushing a symbol 
		onto a list becomes a whole file of classes and methods. So it is a good tool if you want to 
		convince yourself, or someone else, that you are doing a lot of work. </b></i></font></p>
	</blockquote>

	<p>Eric Lippert observed a similar occupational hazard among developers. It&#39;s something he calls
	<a  target="_blank" href="http://blogs.msdn.com/ericlippert/archive/2004/03/18/92422.aspx">object happiness</a>.
	</p>
	<blockquote>
		<font color="#FF0000"><i><b>What I sometimes see when I interview people and review code is 
		symptoms of a disease I call Object Happiness. </b></i></font>Object Happy people feel the need 
		to apply principles of OO design to small, trivial, throwaway projects. They invest lots of 
		unnecessary time making pure virtual abstract base classes -- writing programs where IFoos talk 
		to IBars but there is only one implementation of each interface!

		<p><font color="#FF0000"><i><b>I suspect that early exposure to OO design principles divorced 
		from any practical context that motivates those principles leads to object happiness. People 
		come away as OO True Believers rather than OO pragmatists. </b></i></font></p>
	</blockquote>

	<p>I&#39;ve seen so many problems caused by excessive, slavish adherence to OOP in production applications. 
	Not that object oriented programming is inherently bad, mind you, but <b>a little OOP goes a very 
	long way</b>. Adding objects to your code is like adding salt to a dish: use a little, and it&#39;s 
	a savory seasoning; add too much and it utterly ruins the meal. Sometimes it&#39;s better to err on 
	the side of simplicity, and I tend to favor the approach that results in <i>less</i> code, not
	<i>more</i>. </p>

	<p>Given my ambivalence about all things OO, I was amused when
	<a  target="_blank" href="http://weblogs.asp.net/jgalloway/">Jon Galloway</a> forwarded me a link to
	<a  target="_blank" href="http://smacchia.chez-alice.fr/en/Articles.html">Patrick Smacchia&#39;s web page</a>. Patrick 
	is a French software developer. Evidently the acronym for object oriented programming is spelled 
	a little differently in French than it is in English: POO. </p>
</blockquote>
<blockquote>

	<h6>March 5, 2007</h6>

	<p><b>Todd Blanchard</b></p>
	<blockquote>

		<p>Well, there&#39;s objects and then there&#39;s Objects. I work in Smalltalk - real objects everywhere 
		and it feels pretty natural. </p>

		<p>OTOH, Java&#39;s Objects(TM) are characterized by cargo cult engineering. Lots of form of without 
		function of. Factory is just one pattern that is horrifically overused in that world and usually 
		for no good reason. </p>

		<p>You have to know when to use sense. Very rare in software. Sometimes a script is just a script.&nbsp;
		</p>
	</blockquote>

	<p><b>Opeth </b></p>
	<blockquote>

		<p>Making something ridiculously complex for the sake of making it simple is like trying to 
		put out a fire with gasoline. </p>

		<p>Some programmers just need to take a deep breath and write code that is a delicious salami 
		sandwich, and not an extravagantly prepared four course meal that tastes like shit.</p>
	</blockquote>

	<p><b>Ed </b></p>
	<blockquote>

		<p>“It has been said that democracy is the worst form of government except all the others that 
		have been tried.” - Churchill </p>

		<p>Erm, I guess people do go object-crazy. The problem, as I&#39;m sure is documented elsewhere, 
		is the crappy teaching phase driving home that &quot;OO is about all about inheritance&quot; when it&#39;s 
		not. Inheritance is a powerful tool that is sorely abused. Most of my object hierarchies are 
		flat, I mark all classes as sealed unless I do intend for someone to derive off of them, and 
		I don&#39;t create interfaces until I really need them (and usually it&#39;s only for testing so I can 
		swap in a test implementation). </p>

		<p>OO to me just provides a better way to hide implementation and abstract ideas away so I can 
		create more complex, but logically simpler programs because I don&#39;t have to hold onto all the 
		nuances of everything at once. It&#39;s no panacea, but it is nicer to work with when done right.
		</p>

		<p>Anyways, don&#39;t throw the baby out with the bathwater. Just because some cars suck, do you 
		stop driving altogether? So, until something better comes along ..&nbsp; on March 5, 2007 1:51 
		AM </p>
	</blockquote>

	<p><b>Phil Deneka </b></p>
	<blockquote>

		<p>I second Mr. Haack&#39;s thoughts. I was very fortunate in both high school and college in having 
		teachers who taught both the thinking structure for OOP and why it works. We consistently had 
		to work in groups and be able to read each others&#39; code at a glance and understand what it did, 
		how, and why. </p>

		<p>I didn&#39;t understand just how important that was until many years later. It has shaped every 
		program I&#39;ve touched since. </p>
	</blockquote>

	<p><b>Cesar Viteri</b></p>
	<blockquote>

		<p>I read somewhere the following: &quot;The difference between a terrorist and a Object-Oriented 
		Methodologist is that you can try to negotiate with the terrorist&quot;. A lot of people that behave 
		like you describe in this post make it come true :o) </p>

		<p>Excellent post, keep it coming :o) </p>
	</blockquote>

	<p><b>Thomas Flamer</b></p>
	<blockquote>

		<p>When I studied computer science at the university of Oslo, we had a lecturer called Kristen 
		Nygaard who actually invented object oriented programming. He invented OOP for a language called 
		Simula as a technique for modeling real world objects and beheaviours. You do not have to program 
		OOP in Simula, like in java. </p>
	</blockquote>

	<p><b>dnm</b></p>
	<blockquote>

		<p>I like one of the quotes in Damian Conway&#39;s Perl Best Practices: </p>

		<p>Always write your code as though it will have to be maintained by an angry axe murderer who 
		knows where you live...</p>
	</blockquote>

	<p><b>Eric Turner </b></p>
	<blockquote>

		<p>I think this can be summed up very easily. Bad programming is bad programming no matter the 
		language or the technique used. VB has a bad rap because so many bad programmers coded in it. 
		C had lots of good programmers in the beginning. Not use why in either case, but still true.
		</p>

		<p>OO can be equally bad. A language or technique is neither good or bad. Bad use or implementation 
		of them are however bad. Programmers should be aware of the strengths and weaknesses of each 
		that they do. If they don&#39;t then can they really call themselves programmers. I would say they 
		are just coders. Programmers use the strengths from languages and techniques to reduce the weaknesses. 
		If you don&#39;t then you are just a coder pretending to be a programmer. </p>
	</blockquote>

	<p>Rabid Wolverine</p>
	<blockquote>

		<p><font color="#FF0000"><i><b>They used to call it spaghetti code, OO architects like to call 
		it lasagna code however, most of the time oop winds up as ravioli code…</b></i></font></p>

		<p>ok, we got OOP. we got POO. </p>
	</blockquote>

	<p><b>Dave </b></p>
	<blockquote>

		<p>Let&#39;s make another acronym: Perfect at Objected Oriented Progamming. (POOP). you can make 
		this a certification that people can get by taking an exam or something. it can be sponsored 
		or standardized by different vendors. You can be MCSPOOP, or Sun certified POOP. you can have 
		all different flavors of POOP.(yuck) </p>
	</blockquote>
	Tom
	<blockquote>

		<p>OOP is an excursion into futility.</p>

		<p>It is oversold, anbd rarely are the benfits worth the costs.</p>

		<p>Far from making code clearer it generally adds to obfuscation.</p>

		<p>A methodology or tool, adopted with religious fervour, cannot substitute for good design 
		and high quality coding.</p>

		<p>What is required is clear thought, clear structure, well chosen names, and precise, accurate, 
		and pertinent commenting.</p>

		<p>There is nothing that can be done in C++ or Java that could not be done quicker, more clearly 
		and just as effectively in C, and in other problem domains completely different languages such 
		as LISP and Prolog are in any case more appropriate tools.</p>

		<p>The drawbacks of OOP become most apparent when trying to maintain an OOP-horror. The sequence 
		of procedure calls and values of variables was easily tracked in old-fashioned C. Troubleshooting 
		is an order of magnitude more difficult in C++ or Java.</p>
	</blockquote>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2012_0731_your__code_oop_or_poo"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2011_0907_object_oriented_programming__is_inherently_harmful" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2011_0830_hope_for_multi_language_programming"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Sep 07, 2011] <a  target="_blank" href="http://harmful.cat-v.org/software/OO_programming/">Object Oriented Programming 
is Inherently Harmful</a></h4>
<blockquote>

	<p>Inheritance is more trouble than it&#39;s worth. Under the doubtful disguise of the holy &quot;code reuse&quot; 
	an insane amount of gratuitous complexity is added to our environment, which makes necessary industrial 
	quantities of syntactical sugar to make the ensuing mess minimally manageable.</p>
	<ul>

		<li><a  target="_blank" href="http://doc.cat-v.org/programming/bad_properties_of_OO">Bad Engineering Properties 
		of Object-Oriented Languages by Luca Cardelli</a>.</li>

		<li><a  target="_blank" href="http://harmful.cat-v.org/software/OO_programming/why_oo_sucks">Why OO Sucks by 
		Joe Armstrong</a>.</li>

		<li>
		<a  target="_blank" href="http://harmful.cat-v.org/software/OO_programming/_pdf/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf">
		Pitfalls of Object Oriented Programming</a> - By Tony Albrecht of Sony Computer Entertainment 
		Europe, Research &amp; Development Division.</li>
	</ul>

	<p><b>See Also</b></p>
	<ul>

		<li><a  target="_blank" href="http://www.iwriteiam.nl/AoP_OOCH.html">Object-Oriented Considered Harmful</a> by 
		Frans Faase.</li>

		<li><a  target="_blank" href="http://www.geocities.com/tablizer/oopbad.htm">Object Oriented Programming Oversold!</a></li>

		<li><a  target="_blank" href="http://www.parand.com/say/index.php/2005/07/18/i-hate-patterns/">I Hate Patterns</a> 
		- By Parand Tony Darugar.</li>

		<li><a  target="_blank" href="http://www.paulgraham.com/noop.html">Why arc Isn&#39;t Particularly Object-Oriented</a> 
		- By Paul Graham.</li>

		<li><a  target="_blank" href="http://www.norvig.com/java-iaq.html#del">The questions</a> about inheritance in 
		the Java IAQ.</li>
	</ul>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2011_0907_object_oriented_programming__is_inherently_harmful"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2011_0830_hope_for_multi_language_programming" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2011_0306_object_oriented_programming__is_inherently_harmful"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Aug 30, 2011] <a  target="_blank" href="http://slashdot.org/comments.pl?sid=1144191">Hope For Multi-Language Programming</a></h4>

<h5>&nbsp;Nice: OO pushers as &quot;a hoard of practically illiterate researchers publishing crap papers 
in junk conferences.&quot; ;-)</h5>
<blockquote>
	<b><a  target="_blank" href="http://slashdot.org/comments.pl?sid=1144191&cid=27021181">Re: So you want to learn object 
	oriented now?</a> (<a href="#">Score:5</a>, Informative)</b>

	<p>by <a  target="_blank" href="http://slashdot.org/~smallfries">smallfries (601545)</a> on Saturday February 28, 
	@02:32AM (<a  target="_blank" href="http://slashdot.org/comments.pl?sid=1144191&cid=27021181">#27021181</a>)
	<a  target="_blank" href="http://www.slashdot.org/">Homepage</a> </p>

	<p>I would read it as sarcasm. Try reading
	<a  target="_blank" href="http://www.pbm.com/~lindahl/real.programmers.html">this manifesto</a> [pbm.com] and updating 
	Fortran to C to account for 20 years of shift in the industry. Anyone not using C is just eating 
	Quiche.</p>

	<p>Although his joke went over your head, <font color="#FF0000"><i><b>it is worth pointing out that 
	OO is not a paradigm</b></i></font>. I know wikipedia thinks that it is, and so do
	<font color="#FF0000"><i><b>a hoard of practically illiterate researchers publishing crap papers 
	in junk conferences</b></i></font>. But that doesn&#39;t make it true. </p>

	<p><font color="#FF0000"><i><b>Object Orientation is just a method of [name space] organization 
	for procedural languages. </b></i></font>Although it helps code maintenance and does a better job 
	of unit management that modules alone, it doesn&#39;t change the underlying computational paradigm.
	</p>

	<p>I say procedural languages because class-based programming in functional languages is actually 
	a different type of beast although it gets called OO to appeal to people from an imperative background.</p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2011_0830_hope_for_multi_language_programming"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2011_0306_object_oriented_programming__is_inherently_harmful" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2010_1213_skeptical_quotes_about_oo_programming_and_languages"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Mar 06, 2011] <a  target="_blank" href="http://harmful.cat-v.org/software/OO_programming/">Object Oriented Programming 
is Inherently Harmful</a></h4>

<h5>I would like to warn, that &quot;is Harmful&quot; is a cliche so compromized by
<a  target="_blank" href="http://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger W. Dijkstra</a>&nbsp; that now and 
article with this title should be taken with a grain of salt. </h5>
<ul>

	<li>&quot;<em>Object-oriented programming is an exceptionally bad idea which could only have originated 
	in California.</em>&quot; -- Edsger Dijkstra</li>

	<li>&quot;<em>object-oriented design is the roman numerals of computing.</em>&quot; --
	<a  target="_blank" href="http://genius.cat-v.org/rob-pike/">Rob Pike</a></li>

	<li>&quot;<em>The phrase &quot;object-oriented&quot; means a lot of things. <font color="#FF0000"><b>Half are obvious, 
	and the other half are mistakes</b></font>.</em>&quot; -- Paul Graham</li>

	<li>&quot;<em>Implementation inheritance causes the same intertwining and brittleness that have been 
	observed when goto statements are overused. As a result, OO systems often suffer from complexity 
	and lack of reuse.</em>&quot; -- John Ousterhout <em>Scripting, IEEE Computer, March 1998</em></li>

	<li>&quot;<em>90% of the shit that is popular right now wants to rub its object-oriented nutsack all 
	over my code</em>&quot; -- kfx</li>
</ul>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2011_0306_object_oriented_programming__is_inherently_harmful"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2010_1213_skeptical_quotes_about_oo_programming_and_languages" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2009_1010_the_new__software_crisis"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Dec 13, 2010] Skeptical quotes about OO programming and languages</h4>
<ul>

	<li>“It has been discovered that C++ provides a remarkable facility for concealing the trivial details 
	of a program — such as where its bugs are.” – David Keppel</li>

	<li>&quot;In the one and only true way. The object-oriented version of &#39;Spaghetti code&#39; is, of course, 
	&#39;Lasagna code&#39;. (Too many layers).&quot; - Roberto Waltman. </li>

	<li>“Java is the most distressing thing to hit computing since MS-DOS.” – Alan Kay</li>
</ul>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2010_1213_skeptical_quotes_about_oo_programming_and_languages"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2009_1010_the_new__software_crisis" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2008_0228_objecting__to_objects_by_stephen_c_johnson"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Oct 10, 2009] <a  target="_blank" href="http://www.bcs.org/server.php?show=ConWebDoc.18854">The new 
software crisis </a></h4>

<h5>&quot;If the principles of OOP are introduced too early it may lead to cognitive overload for some students 
resulting in confusion and disillusionment with the subject.&quot;</h5>
<blockquote>

	<h6><a  target="_blank" href="http://www.bcs.org/server.php?show=ConWebDoc.18854">BCS - The Chartered Institute for 
	IT</a></h6>

	<p>Historically, research suggests that students have always found computer programming difficult; 
	the abstract nature of programming involving problem solving and logical thinking requires a certain 
	aptitude, and the necessary skills and disciplines are not always easy to learn and execute.</p>

	<p>Even students who are bright and successful in other areas of study often struggle to grasp the 
	basics of programming, and this has traditionally led to higher than average failure and drop-out 
	rates. Many students end up disillusioned and look for ways to avoid the subject later in the programme.</p>

	<p>Modern programming paradigms, based upon the object-oriented programming (OOP) paradigm, and 
	introduced in recent years, have additional complex concepts and constraints associated with them.</p>

	<p>OOP languages such as Java and VB.NET are now widely used for teaching introductory programming 
	modules in many universities. <font color="#FF0000"><i><b>These place an additional cognitive burden 
	on students over and above the already difficult programming principles associated with all programming 
	languages.</b></i></font></p>

	<p>Many students complain that they find it difficult to understand some of the complexities associated 
	with object orientation. Trying to deal with these concepts at an early stage leads to having less 
	time to focus on more fundamental principles and often results in students having a poorer understanding 
	of the basics.</p>

	<p>Add to this the need to include modern windows programming environments with graphics controls 
	and event handling, and it all becomes too much for many students to handle; they simply cannot 
	see the wood for the trees. </p>

	<p><font color="#FF0000"><i><b>If the principles of OOP are introduced too early it may lead to 
	cognitive overload for some students resulting in confusion and disillusionment with the subject.</b></i></font></p>

	<p>This additional complexity makes the problem of teaching contemporary programming at an introductory 
	level even more acute and if not addressed is&nbsp; likely to lead to even higher failure and drop-out 
	rates in the early phases of computing programmes, with more students trying to avoid programming 
	at all costs. </p>

	<p>Why is it that students find programming courses more difficult than they did in the past?</p>

	<p>One reason is that the range of abilities of student cohorts has undoubtedly widened in recent 
	years. Another is simply that OOP programming is more complex and difficult to understand. It has 
	often been suggested that the difficulty in the teaching and understanding of a programming language 
	can be seen by examining the complexity of the ubiquitous &#39;Hello World&#39; program.</p>

	<p>The &#39;Hello World&#39; program illustrates the simplest form of human-computer interaction (HCI); 
	it sends a text message from a computer program to the user, displayed on the screen. &#39;Hello World&#39; 
	will be familiar to many computer lecturers and students as it is considered to be the most basic 
	of programs, and is normally used as the first program example in many undergraduate programming 
	text books and introductory programming modules.</p>

	<p>To illustrate the additional complexity of OOP consider as a simple metric the comparison of 
	the program code for &#39;Hello World&#39; written in Pascal, a language used in many universities to teach 
	introductory programming in the past, and Java a contemporary OOP language widely used commercially 
	and in universities today to teach programming.</p>

	<p><strong>PASCAL:</strong></p>
	<blockquote>

		<p><font color="#0000FF">program HelloWorld<br>
		begin<br>
&nbsp;&nbsp; write (&#39;Hello World&#39;)<br>
		end.</font></p>
	</blockquote>

	<p><strong>JAVA:</strong></p>
	<blockquote>

		<p><font color="#0000FF">class Message<br>
		{<br>
&nbsp;&nbsp; public static void main (String args[ ])<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message helloWorld = new Message ( );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; helloWorld.printMessage ( );<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; void printMessage ( )<br>
&nbsp;&nbsp; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.print (&quot;Hello World&quot;);<br>
&nbsp;&nbsp; }<br>
		}</font></p>
	</blockquote>

	<p>These two programs perform exactly the same function. It is not difficult to see that the early 
	generation Pascal program is very simple and easy to understand, most students and even most ordinary 
	adults would have no problem understanding what is going on.</p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2009_1010_the_new__software_crisis"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2008_0228_objecting__to_objects_by_stephen_c_johnson" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2007_0926_will_ruby_kill_php"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Feb 28, 2008]
<a  target="_blank" href="http://www.usenix.org/publications/library/proceedings/sf94/full_papers/johnson.html">Objecting 
to Objects, by Stephen C. Johnson</a></h4>

<h5>&quot;Although there have been, and will always be, religious fanatics who think their language is the 
only way to code, the really organized OOP hype started in the late 1980&#39;s. &quot;...&nbsp; &quot;It is said that 
countries get the governments they deserve, and perhaps that is true of professions as well--a lot of 
the energy fueling this hype derives from the truly poor state of software development.&quot; </h5>
<blockquote>

	<h6>1994 | USENIX</h6>

	<p>Object Oriented Programming (OOP) is currently being hyped as the best way to do everything from 
	promoting code reuse to forming lasting relationships with persons of your preferred sexual orientation. 
	This paper tries to demystify the benefits of OOP. We point out that, as with so many previous software 
	engineering fads, the biggest gains in using OOP result from applying principles that are older 
	than, and largely independent of, OOP. Moreover, many of the claimed benefits are either not true 
	or true only by chance, while occasioning some high costs that are rarely discussed. Most seriously, 
	all the hype is preventing progress in tackling problems that are both more important and harder: 
	control of parallel and distributed applications, GUI design and implementation, fault tolerant 
	and real-time programming. OOP has little to offer these areas. Fundamentally, you get good software 
	by thinking about it, designing it well, implementing it carefully, and testing it intelligently, 
	not by mindlessly using an expensive mechanical process. </p>

	<p><b>Define Your Terms</b></p>

	<p>Object Oriented Programming (OOP) is a term largely borrowed from the SmallTalk community, who 
	were espousing many of these techniques in the mid 1970&#39;s. In turn, many of their ideas derive from 
	Simula 67, as do most of the core ideas in C++. Key notions such as encapsulation and reuse have 
	been discussed as far back as the 60&#39;s, and received a lot of discussion during the rounds of the 
	Ada definition. <font color="#FF0000"><i><b>Although there have been, and will always be, religious 
	fanatics who think their language is the only way to code, the really organized OOP hype started 
	in the late 1980&#39;s. </b></i></font>By the early 1990&#39;s, both Next and Microsoft were directing their 
	marketing muscle into persuading us to give up C and adopt C++, while SmallTalk and Eiffel both 
	were making a respectable showing, and object oriented operating systems and facilities (DOE, PenPoint, 
	COBRA) were getting a huge play in the trade press--the hype wars were joined. </p>

	<p><font color="#FF0000"><i><b>It is said that countries get the governments they deserve, and perhaps 
	that is true of professions as well--a lot of the energy fueling this hype derives from the truly 
	poor state of software development.</b></i></font> While hardware developers have provided a succession 
	of products with radically increasing power and lower cost, the software world has seen very little 
	productivity improvement. Major, highly visible products from industry leaders continue to be years 
	late (Windows NT), extremely buggy (Solaris) or both, costs skyrocket, and, most seriously, people 
	are very reluctant to pay 1970&#39;s software costs when they are running cheap 1990&#39;s hardware. I believe 
	a lot of non-specialists look at software development and see it as so completely screwed up that 
	the cause cannot be profound--it must be something simple, something a quick fix could fix. Maybe 
	if they just used objects... </p>

	<p>To be more precise, most of what I say will apply to C++, viewed as a poor stepchild by most 
	of the OOP elite. Actually, the few comments I will make about more dynamically typed languages 
	like SmallTalk make C++ look good by comparison. I will also focus my concern fairly narrowly.
	<font color="#FF0000"><i><b>I am interested in tools, including languages, that make it easier and 
	more productive to generate large serious high quality software products. So focusing rules out 
	a bunch of sometimes entertaining philosophical and aesthetic arguments best entertained over beer.
	</b></i></font></p>

	<p><font color="#FF0000"><b><i>... ... ...</i></b></font></p>

	<h6>What Works in OOP</h6>

	<p>Those who report big benefits from using OOP are not lying. Many of the reported benefits come 
	from focusing on designing the software models, including the roles and interactions of the modules, 
	enabling the modules to encapsulate expertise, and carefully designing the interfaces between these 
	modules. While most OOP systems allow you, and even encourage you, to do these things, most older 
	programming systems allow these techniques as well. These are good, old ideas that have proved their 
	worth in the trenches for decades, whether they were called OOP, structured programming, or just 
	common sense. I have seen excellent programs written in assembler that used these principles, and 
	terrible programs in C++ that did not. The use of objects and inheritance is not what makes these 
	programs good. </p>

	<p>What works in all these cases is that the programs were well thought out and the design was done 
	intelligently, based on a clear and well communicated set of organizing principles. The language 
	and the operating system just don&#39;t matter. In many cases, the same organizing principles used to 
	guide the design can be used to guide the construction and testing of the product as well. What 
	makes a piece of software good has a lot to do with the application of thought to the problem being 
	addressed, and not much to do with what language or methodology you used. To the extent that the 
	OOP methodology makes you think problems through and forces you to make hidden assumptions explicit, 
	it leads to better code. </p>

	<p><b>OOP Claims Unmasked</b></p>

	<p>The hype for OOP usually claims benefits such as faster development time, better code reuse, 
	and higher quality and reliability of the final code. As the last section shows, these are not totally 
	empty claims, but when true they don&#39;t have much to do with OOP methodology. This section examines 
	these claims in more detail. </p>

	<p>OOP is supposed to allow code to be developed faster; the question is, &quot;faster than what?&quot;. Will 
	OOP let you write a parser faster than Yacc, or write a GUI faster than using a GUI-builder? Will 
	your favorite OOP replace <code>awk</code> or Perl or <code>csh</code> within a few years? I think 
	not. </p>

	<p>Well, maybe faster than C, and I suppose if we consider only raw C this claim has some validity. 
	But a large part of most OOP environments is a rich set of classes that allow the user to manipulate 
	the environment--build windows, send messages across a network, receive keystrokes, etc. C, by design, 
	has a much thinner package of such utilities, since it is used in so many different environments. 
	There were some spectacularly productive environments based on LISP a few years back (and not even 
	the most diehard LISP fanatic would say that LISP is object oriented). A lot of what made these 
	environments productive was a rich, well designed set of existing functions that could be accessed 
	by the user. An that is a lot of what makes OOP environments productive compared to raw C. Another 
	way of saying this is that a lot of the productivity improvement comes from code reuse. </p>

	<p>There is probably no place where the OOP claims are more misleading than the claims of code reuse. 
	In fact, code reuse is a complex and difficult problem--it has been recognized as desirable for 
	decades, and the issues that make it hard are not materially facilitated by OOP. </p>

	<p>In order for me to reuse your code, your code needs to do something that I want done (that&#39;s 
	the easy part), and your code needs to operate within the same model of the program and environment 
	as my code (that&#39;s the hard part). OOP addresses some of the gratuitous problems that occasionally 
	plagued code reuse attempts (for example, issues of data layout), but the fundamental problems are, 
	and remain, hard. </p>

	<p>An example should make this clearer. One of the most common examples of a reused program is a 
	string package (this is particularly compelling in C++, since C has such limited string handling 
	facilities). Suppose you have written a string package in C++, and I want to use it in my compiler 
	symbol table. As it happens, many of the strings that a compiler uses while compiling a function 
	do not need to be referenced after that function has been compiled. This is commonly dealt with 
	by providing an arena-based allocator, where storage can be allocated out of an arena associated 
	with a function, and then the whole arena can be discarded when the function has been processed. 
	This minimizes the chance of memory leaks and makes the deallocation of storage essentially free 
	(Similar techniques are used to handle transaction-based storage in a transaction processing system, 
	etc.). </p>

	<p>So, I want to use your string package, but I want your string package to use my arena-based allocator. 
	But, almost certainly, you have encapsulated knowledge of storage allocation so that I can&#39;t have 
	any contact with it (that is a <em>feature</em> of OOP, after all), so I can&#39;t use your package 
	with my storage allocator. Actually, I would probably have more luck reusing your package had it 
	been in C, since I could supply my own <code>malloc</code> and <code>free</code> routines (although 
	that has its own set of problems). </p>

	<p>If you had designed your string package to allow me to specify the storage allocator, then I 
	could use it. But this just makes the point all the more strongly. The reason we do not reuse code 
	is that most code is not designed to be reused (notice I said nothing about implementation). When 
	code <em>is</em> designed to be reused (the C standard library comes to mind) it doesn&#39;t need object 
	oriented techniques to be effective. I will have more to say about reuse by inheritance below.
	</p>

	<p>One of the major long-term advantages of object-oriented techniques may be that it can support 
	broad algorithmic reuse, of a style similar to the Standard Template Library of C++.
	<font color="#FF0000"><i><b>However, the underlying language is enormously overbuilt for such support, 
	allowing all sorts of false traps and dead-ends for the unwary. </b></i></font>The Standard Template 
	Library took several generations and a dozen of the best minds in the C++ community to reach its 
	current state, and it&#39;s no mistake that several of the early generations were coded in Ada and SCHEME--its 
	power is not in the language, but in the ideas. </p>

	<p><font color="#FF0000"><i><b>The final advantage claimed for OOP is higher quality code. Here 
	again, there is a germ of truth to this claim, since some problems with older methods (such as name 
	clashes in libraries) are harder to make and easier to detect using OOP. To the extent that we can 
	reuse &quot;known good&quot; code, our quality will increase--this doesn&#39;t depend on OOP. However, basically 
	code quality depends on intelligent design, an effective implementation process, and aggressive 
	testing. OOP does not address the first or last step at all, and falls short in the implementation 
	step. </b></i></font></p>

	<p>For example, we might wish to enforce some simple style rules on our object implementations, 
	such as requiring that every object have a <code>print </code>method or a <code>serialize</code> 
	method for dumping the object to disc. The best that many object- oriented systems can do is provide 
	you (or, rather, your customer) with a run-time error when you try to dump an object to disc that 
	has not defined such a method (C++ actually does a bit better than that). Many of the more dynamically 
	typed systems, such as SmallTalk or PenPoint, do not provide any typing of arguments of messages, 
	or enforce any conventions as to which messages can be sent to which objects. This makes messages 
	as unstructured as GOTO&#39;s were in the 1970&#39;s, with a similar impact on correctness and quality.
	</p>

	<p>One of the most unfortunate effects of the OOP bandwagon is that it encourages the belief that 
	how you speak is more important than what you say. It is rather like suggesting that if someone 
	uses perfect English grammar they must be truthful. It <em>is</em> what you say, and <em>not</em> 
	how you say it. </p>

	<p>... ... ...</p>

	<p><b>He said that She said that He had Halitosis</b></p>

	<p><font color="#FF0000"><i><b>Using a computer language is a social, and even political act, akin 
	to voting for a candidate or buying a certain brand of car. As such, our choices are open to manipulation 
	by marketeers, influence by fads, and various forms of rationalization by those who were burned 
	and have trouble admitting it.</b></i></font> In particular, much of what is &quot;known&quot; about a language 
	is something that was true, or at widely believed, at one point in the language&#39;s history, but may 
	not be true currently. At one point, &quot;everybody&quot; knew that PL/I had no recursive functions, ALGOL 
	68 was too big a language to be useful, Ada was too slow, and C could not be used for numerical 
	problems. Some of these beliefs were never true, and none of them are true now, but they are still 
	widely held. It is worth looking at OOP in this light. </p>

	<p>Some of the image manipulators target nontechnical people such as our bosses and customers, and 
	may try to persuade them that OOP would solve their problems. As we have seen, however, many of 
	the things that are &quot;true&quot; of OOP (for example, that it makes reuse easy) are difficult to justify 
	when you look more carefully. As professionals, it is our responsibility to ask whether moving to 
	OOP is in the best interests of ourselves, our company, or our profession. We must also have the 
	courage to reject the fad when it is a diversion or will not meet our needs. We must also make this 
	decision anew for each project, considering all the potential factors. Realistically, the answer 
	will probably be that some projects should use OOP, others should not, and for a fair number in 
	the middle it doesn&#39;t matter very much. </p>

	<p><b>Summary</b></p>

	<p>The only way to construct good software is to think about it. Since the scope of problems that 
	software attempts to address is so vast, the kinds of solutions that that we need is also vast. 
	OOP is a good tool to have in our toolbox, and there are places that it is my tool of choice. But 
	there are also places where I would avoid it like the plague. It is important to all of us that 
	we continue to have that option. </p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2008_0228_objecting__to_objects_by_stephen_c_johnson"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2007_0926_will_ruby_kill_php" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2007_0307_coding_horror_your__code_oop_or_poo"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Sep 26, 2007] <a  target="_blank" href="http://www.killerphp.com/articles/will-ruby-kill-php/">Will Ruby kill PHP</a></h4>

<h5>&quot;OO is definitely overkill for a lot of web projects.&quot; ...&nbsp; </h5>
<blockquote>

	<h6><a  target="_blank" href="http://www.killerphp.com/articles/will-ruby-kill-php/">Blog Archive KILLERPHP.COM</a></h6>

	<p><font color="#FF0000"><i><b>OO is definitely overkill for a lot of web projects.</b></i></font> 
	It seems to me that so many people use OO frameworks like Ruby and Zope because “it’s enterprise 
	level”. <font color="#FF0000"><i><b>But using an ‘enterprise’ framework for small to medium sized 
	web applications just adds so much overhead and frustration at having to learn the framework that 
	it just doesn&#39;t seem worth it to me.</b></i></font> Having said all this I must point out that
	<font color="#FF0000"><i><b>I’m distrustful of large corporations and hate their dehumanizing hierarchical 
	structure. </b></i></font>Therefore i am naturally drawn towards open source and away from the whole 
	OO/enterprise/hierarchy paradigm. Maybe people want to push open source to the enterprise level 
	in the hope that they will adopt the technology and therefore they will have more job security. 
	Get over it - go and learn Java and .NET if you want job security and preserve open source software 
	as an oasis of freedom away from the corporate world. Just my 2c.</p>

	<p>===</p>

	<p>OOP has its place, but the diversity of frameworks is just as challenging to figure out as a 
	new class you didn’t write, if not more. None of them work the same or keep a standard convention 
	between them that makes learning them easier. <font color="#FF0000"><i><b>Frameworks are great, 
	but sometimes I think maybe they don’t all have to be OO</b></i></font>. I keep a small personal 
	library of functions I’ve (and others have) written procedurally and include them just like I would 
	a class. Beyond the overhead issues is complexity. OOP has you chasing declarations over many files 
	to figure out what’s happening. If you’re trying to learn how that unique class you need works, 
	it can be time consuming to read through it and see how the class is structured. By the time you’re 
	done you may as well have written the class yourself, at least by then you’d have a solid understanding. 
	Encapsulation and polymorphism have their advantages, but the cost is complexity which can equal 
	time. And for smaller projects that will likely never expand, that time and energy can be a waste.</p>

	<p>Not trying to bash OOP, just to defend procedural style. They each have their place. </p>

	<p>===</p>

	<p>Sorry, but I don’t like your text, because you mix Ruby and Ruby on Rails alot. Ruby is in my 
	opinion easier to use then PHP, because PHP has no design-principle beside “make it work, somehow 
	easy to use”. Ruby has some really cool stuff I miss quite often, when I have to program in PHP 
	again (blocks for example), but has a more clear and logical syntax.</p>

	<p>Ruby on Rails is of course not that easy to use, at least when speaking about small-scale projects. 
	This is, because it does a lot more than PHP does. Of course, there are other good reasons to prefere 
	PHP over Rails (like the better support by providers, more modules, more documentation), but from 
	my opinion, most projects done in PHP from the complexity of a blog could profit from being programmed 
	in Rails, from the pure technical point of view. At least I won’t program in PHP again unless a 
	customer asks me. </p>

	<p>===</p>

	<p>I have a reasonable level of experience with PHP and Python but unfortunately haven’t touched 
	Ruby yet. They both seem to be a good choice for low complexity projects. I can even say that I 
	like Python a lot. But I would never consider it again for projects where design is an issue. They 
	also say it is for (rapid) prototyping. My experience is that as long as you can’t afford a proper 
	IDE Python is maybe the best place to go to. <font color="#FF0000"><i><b>But a properly “equipped” 
	environment can formidably boost your productivity with a statically typed language like Java.</b></i></font> 
	In that case Python’s advantage shrinks to the benefits of quick tests accesible through its command 
	line.</p>

	<p><font color="#FF0000"><i><b>Another problem of Python is that it wants to be everything: simple 
	and complete, flexible and structured, high-level while allowing for low-level programming. The 
	result is a series of obscure features</b></i></font></p>

	<p>Having said all that I must give Python all the credits of a good language. It’s just not perfect. 
	Maybe it’s Ruby. My apologies for not sticking too closely to the subject of the article. </p>

	<p>===</p>

	<p>The one thing I hate is OOP geeks trying to prove that they can write code that does nothing 
	usefull and nobody understands.</p>

	<p><font color="#FF0000"><i><b>“You don&#39;t have to use OOP in ruby! You can do it PHP way! So you 
	better do your homework before making such statements!”</b></i></font></p>

	<p>Then why use ruby in the first place?</p>

	<p>“What is really OVERKILL to me, is to know the hundreds of functions, PHP provides out of the 
	box, and available in ANY scope! So I have to be extra carefull wheter I can use some name. And 
	the more functions - the bigger the MESS.”</p>

	<p>On the other hand, in ruby you use only functions avaliable for particullar object you use.</p>

	<p>I would rather say: “some text”.length than strlen(”some text”); which is much more meaningful! 
	Ruby language itself much more descriptive. I remember myself, from my old PHP days, heaving alwayse 
	to look up the php.net for appropriate function, but now I can just guess!”</p>

	<p>Yeah you must have weak memory and can`t remember wheter strlen() is for strings or for numbers….</p>

	<p>Doesn`t ruby have the same number of functions just stored in objects?</p>

	<p>Look if you can`t remember strlen than invent your own classes you can make a whole useless OOP 
	framework for PHP in a day…… </p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2007_0926_will_ruby_kill_php"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2007_0307_coding_horror_your__code_oop_or_poo" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2007_0507_the_hundred_year_language"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Mar 7, 2007] <a  target="_blank" href="http://www.codinghorror.com/blog/archives/000801.html">Coding Horror Your 
Code OOP or POO</a> by Jeff Atwood </h4>

<h5>&quot;I&#39;ve seen so many problems caused by excessive, slavish adherence to OOP in production applications. 
Not that object oriented programming is inherently bad, mind you, but a little OOP goes a very long 
way. Adding objects to your code is like adding salt to a dish: use a little, and it&#39;s a savory seasoning; 
add too much and it utterly ruins the meal. Sometimes it&#39;s better to err on the side of simplicity, 
and I tend to favor the approach that results in less code, not more. &quot;</h5>
<blockquote>

	<p>I&#39;m not a fan of object orientation for the sake of object orientation. Often the proper OO way 
	of doing things ends up being <a  target="_blank" href="http://www.codinghorror.com/blog/archives/000617.html">a 
	productivity tax</a>. Sure, objects are the backbone of any modern programming language, but sometimes 
	I can&#39;t help feeling that <a  target="_blank" href="http://www.codinghorror.com/blog/archives/000033.html">slavish 
	adherence to objects is making my life a lot more difficult</a>. I&#39;ve always found
	<a  target="_blank" href="http://www.codinghorror.com/blog/archives/000042.html">inheritance hierarchies to be brittle 
	and unstable</a>, and then there&#39;s the massive
	<a  target="_blank" href="http://www.codinghorror.com/blog/archives/000621.html">object-relational divide</a> to 
	contend with. OO seems to bring at least as many problems to the table as it solves. </p>

	<p>Perhaps Paul Graham <a  target="_blank" href="http://www.paulgraham.com/noop.html">summarized it best</a>: </p>
	<blockquote>
		Object-oriented programming generates a lot of what looks like work. Back in the days of fanfold, 
		there was a type of programmer who would only put five or ten lines of code on a page, preceded 
		by twenty lines of elaborately formatted comments. Object-oriented programming is like crack 
		for these people: it lets you incorporate all this scaffolding right into your source code. 
		Something that a Lisp hacker might handle by pushing a symbol onto a list becomes a whole file 
		of classes and methods. So it is a good tool if you want to convince yourself, or someone else, 
		that you are doing a lot of work.
	</blockquote>

	<p>Eric Lippert observed a similar occupational hazard among developers. It&#39;s something he calls
	<a  target="_blank" href="http://blogs.msdn.com/ericlippert/archive/2004/03/18/92422.aspx">object happiness</a>.
	</p>
	<blockquote>
		What I sometimes see when I interview people and review code is symptoms of a disease I call 
		Object Happiness. Object Happy people feel the need to apply principles of OO design to small, 
		trivial, throwaway projects. They invest lots of unnecessary time making pure virtual abstract 
		base classes -- writing programs where IFoos talk to IBars but there is only one implementation 
		of each interface! I suspect that early exposure to OO design principles divorced from any practical 
		context that motivates those principles leads to object happiness. People come away as OO True 
		Believers rather than OO pragmatists.
	</blockquote>

	<p>I&#39;ve seen so many problems caused by excessive, slavish adherence to OOP in production applications. 
	Not that object oriented programming is inherently bad, mind you, but <b>a little OOP goes a very 
	long way</b>. Adding objects to your code is like adding salt to a dish: use a little, and it&#39;s 
	a savory seasoning; add too much and it utterly ruins the meal. Sometimes it&#39;s better to err on 
	the side of simplicity, and I tend to favor the approach that results in <i>less</i> code, not
	<i>more</i>. </p>

	<p>Given my ambivalence about all things OO, I was amused when
	<a  target="_blank" href="http://weblogs.asp.net/jgalloway/">Jon Galloway</a> forwarded me a link to
	<a  target="_blank" href="http://smacchia.chez-alice.fr/en/Articles.html">Patrick Smacchia&#39;s web page</a>. Patrick 
	is a French software developer. Evidently the acronym for object oriented programming is spelled 
	a little differently in French than it is in English: POO. </p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2007_0307_coding_horror_your__code_oop_or_poo"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2007_0507_the_hundred_year_language" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2007_0501_subtyping_subclassing_and__trouble_with_oop"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[May 7, 2007] <a  target="_blank" href="http://www.paulgraham.com/hundred.html">The Hundred-Year Language</a> by 
Paul Graham</h4>

<h5>&quot;I don&#39;t predict the demise of object-oriented programming, by the way. Though I don&#39;t think it 
has much to offer good programmers, except in certain specialized domains, it is irresistible to large 
organizations. Object-oriented programming offers a sustainable way to write spaghetti code. It lets 
you accrete programs as a series of patches.&nbsp; Large organizations always tend to develop software 
this way, and I expect this to be as true in a hundred years as it is today.&quot;&nbsp;
<font color="#FF0000">-- This is a pretty interesting observation which links some (objectionable) properties 
of OO with the properties of the large organizations. </font></h5>
<blockquote>

	<h6>April 2003&nbsp; | Keynote from PyCon2003</h6>

	<p>...I have a hunch that the main branches of the evolutionary tree pass through the languages 
	that have the smallest, cleanest cores. The more of a language you can write in itself, the better.</p>

	<p>...Languages evolve slowly because they&#39;re not really technologies. Languages are notation. A 
	program is a formal description of the problem you want a computer to solve for you. So the rate 
	of evolution in programming languages is more like the rate of evolution in mathematical notation 
	than, say, transportation or communications. Mathematical notation does evolve, but not with the 
	giant leaps you see in technology.</p>

	<p>...I learned to program when computer power was scarce. I can remember taking all the spaces 
	out of my Basic programs so they would fit into the memory of a 4K TRS-80. The thought of all this 
	stupendously inefficient software burning up cycles doing the same thing over and over seems kind 
	of gross to me. But I think my intuitions here are wrong. I&#39;m like someone who grew up poor, and 
	can&#39;t bear to spend money even for something important, like going to the doctor.</p>

	<p>Some kinds of waste really are disgusting. SUVs, for example, would arguably be gross even if 
	they ran on a fuel which would never run out and generated no pollution. SUVs are gross because 
	they&#39;re the solution to a gross problem. (How to make minivans look more masculine.) But not all 
	waste is bad. Now that we have the infrastructure to support it, counting the minutes of your long-distance 
	calls starts to seem niggling. If you have the resources, it&#39;s more elegant to think of all phone 
	calls as one kind of thing, no matter where the other person is.</p>

	<p>There&#39;s good waste, and bad waste. I&#39;m interested in good waste-- the kind where, by spending 
	more, we can get simpler designs. How will we take advantage of the opportunities to waste cycles 
	that we&#39;ll get from new, faster hardware?</p>

	<p>The desire for speed is so deeply engrained in us, with our puny computers, that it will take 
	a conscious effort to overcome it. In language design, we should be consciously seeking out situations 
	where we can trade efficiency for even the smallest increase in convenience.</p>

	<p><font color="#FF0000"><i><b>Most data structures exist because of speed. For example, many languages 
	today have both strings and lists. Semantically, strings are more or less a subset of lists in which 
	the elements are characters. So why do you need a separate data type? You don&#39;t, really. Strings 
	only exist for efficiency. But it&#39;s lame to clutter up the semantics of the language with hacks 
	to make programs run faster. Having strings in a language seems to be a case of premature optimization.</b></i></font></p>

	<p>... Inefficient software isn&#39;t gross. What&#39;s gross is a language that makes programmers do needless 
	work. Wasting programmer time is the true inefficiency, not wasting machine time. This will become 
	ever more clear as computers get faster </p>

	<p>...Somehow the idea of reusability got attached to object-oriented programming in the 1980s, 
	and no amount of evidence to the contrary seems to be able to shake it free. But although some object-oriented 
	software is reusable, what makes it reusable is its bottom-upness, not its object-orientedness. 
	Consider libraries: they&#39;re reusable because they&#39;re language, whether they&#39;re written in an object-oriented 
	style or not.</p>

	<p><i><b>I don&#39;t predict the demise of object-oriented programming, by the way. Though I don&#39;t think 
	it has much to offer good programmers, except in certain specialized domains, it is irresistible 
	to large organizations. Object-oriented programming offers a sustainable way to write spaghetti 
	code. It lets you accrete programs as a series of patches.&nbsp; Large organizations always tend 
	to develop software this way, and I expect this to be as true in a hundred years as it is today.</b></i></p>

	<p><b><i><font color="#FF0000">...</font></i></b>As this gap widens, profilers will become increasingly 
	important. Little attention is paid to profiling now. Many people still seem to believe that the 
	way to get fast applications is to write compilers that generate fast code. As the gap between acceptable 
	and maximal performance widens, it will become increasingly clear that the way to get fast applications 
	is to have a good guide from one to the other.</p>

	<p>...One of the most exciting trends in the last ten years has been the rise of open-source languages 
	like Perl, Python, and Ruby. Language design is being taken over by hackers. The results so far 
	are messy, but encouraging. <font color="#FF0000"><i><b>There are some stunningly novel ideas in 
	Perl, for example.</b></i></font> Many are stunningly bad, but that&#39;s always true of ambitious efforts. 
	At its current rate of mutation, God knows what Perl might evolve into in a hundred years.</p>

	<p>...One helpful trick here is to use the <a  target="_blank" href="http://www.paulgraham.com/power.html">length</a> 
	of the program as an approximation for how much work it is to write. Not the length in characters, 
	of course, but the length in distinct syntactic elements-- basically, the size of the parse tree.
	<font color="#FF0000"><i><b>It may not be quite true that the shortest program is the least work 
	to write, but it&#39;s close enough that you&#39;re better off aiming for the solid target of brevity than 
	the fuzzy, nearby one of least work.</b></i></font> <font color="#FF0000"><i><b>Then the algorithm 
	for language design becomes: look at a program and ask, is there any way to write this that&#39;s shorter?</b></i></font></p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2007_0507_the_hundred_year_language"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2007_0501_subtyping_subclassing_and__trouble_with_oop" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2006_1215_the__mythical_open_source_miracle"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[May 1, 2007] <a  target="_blank" href="http://okmij.org/ftp/Computation/Subtyping/">Subtyping, Subclassing, and 
Trouble with OOP</a></h4>
<blockquote>

	<p>An extensive discussion of subtyping, insidious problems with subclassing, and practical rules 
	to avoid them. </p>
	<dl>
		<dt><a href="#Problem">Does OOP really separate interface from implementation?</a> </dt>
		<dd>The manifestation of a problem: an example of how an implementation inheritance prevents 
		separation of interface and implementation </dd>
		<dt><a href="#Problem-cause">Subtyping vs. Subclassing</a> </dt>
		<dd>Explanation why the problem above happened </dd>
		<dt><a  target="_blank" href="http://okmij.org/ftp/Computation/Subtyping/Preventing-Trouble.html">Subclassing 
		errors, OOP style and practically checkable to prevent them</a> </dt>
		<dd>Demonstration how statically checkable rules can prevent the problem from occurring
		<font size="-1">[a separate document]</font> </dd>
	</dl>

	<p>A more formal and general presentation of this topic is given in a paper and a talk at a Monterey 
	2001 workshop (June 19-21, 2001, Monterey, CA):&nbsp;
	<a  target="_blank" href="http://okmij.org/ftp/papers/Subtyping-OOP.ps.gz">Subtyping-OOP.ps.gz</a> [35K]&nbsp;&nbsp; 
	and&nbsp;&nbsp;&nbsp; <a  target="_blank" href="http://okmij.org/ftp/papers/MTR2001-Subtyping-talk.ps.gz">MTR2001-Subtyping-talk.ps.gz</a> 
	[67K]&nbsp;&nbsp; <a name="Problem">&nbsp;</a> </p>

	<p><b>Does OOP really separate interface from implementation?</b></p>

	<p>Decoupling of abstraction from implementation is one of the holy grails of good design. Object-oriented 
	programming in general and encapsulation in particular are claimed to be conducive to such separation, 
	and therefore to more reliable code. In the end, productivity and quality are the only true merits 
	a programming methodology is to be judged upon. This article is to show a very simple example that 
	questions if OOP indeed helps separate interface from implementation. The example is a very familiar 
	one, illustrating the difference between subclassing and subtyping. The article carries this example 
	of Bags and Sets one step further, to a rather unsettling result. The article set out to follow 
	good software engineering; this makes the resulting failure even more ominous. </p>

	<p>The article aims to give a more-or-less &quot;real&quot; example, which one can run and see the result 
	for himself. By necessity the example had to be implemented in some language. The present article 
	uses C++. It appears however that similar code (with similar conclusions) can be carried on in many 
	other OO languages (e.g., Java, Python, etc). </p>

	<p>Suppose I was given a task to implement a Bag -- an unordered collection of possibly duplicate 
	items (integers in this example). I chose the following interface: </p>

	<table cellspacing="0" cellpadding="0" width="95%" align="right" border="0" id="table20">
		<tr>
			<td bgcolor="#e0e0e0">

			<pre>typedef int const * CollIterator;	// Primitive but will do
class CBag {
 public:
  int size(void) const;			// The number of elements in the bag
  virtual void put(const int elem);	// Put an element into the bag
  int count(const int elem) const;	// Count the number of occurrences
				        // of a particular element in the bag
  virtual bool del(const int elem);     // Remove an element from the bag
					// Return false if the element
					// didn&#39;t exist
  CollIterator begin(void) const;	// Standard enumerator interface
  CollIterator end(void) const;

  CBag(void);
  virtual CBag * clone(void) const;	// Make a copy of the bag
 private:
			// implementation details elided
};</pre>
			</td>
		</tr>
	</table>

	<br clear="all">
	Other useful operations of the CBag package are implemented without the knowledge of CBag&#39;s internals. 
	The functions below use only the public interface of the CBag class:<br>
&nbsp;<table cellspacing="0" cellpadding="0" width="95%" align="right" border="0" id="table21">
		<tr>
			<td bgcolor="#e0e0e0">

			<pre>// Standard &quot;print-on&quot; operator
ostream&amp; operator &lt;&lt; (ostream&amp; os, const CBag&amp; bag);

// Union (merge) of the two bags
// The return type is void to avoid complications with subclassing
// (which incidental to the current example)
void operator += (CBag&amp; to, const CBag&amp; from);

// Determine if CBag a is subbag of CBag b
bool operator &lt;= (const CBag&amp; a, const CBag&amp; b);

inline bool operator &gt;= (const CBag&amp; a, const CBag&amp; b)
{ return b &lt;= a; }

// Structural equivalence of the bags
// Two bags are equal if they contain the same number of the same elements
inline bool operator == (const CBag&amp; a, const CBag&amp; b)
{ return a &lt;= b &amp;&amp; a &gt;= b; }</pre>
			</td>
		</tr>
	</table>

	<br clear="all">
&nbsp;

	<p>It has to be stressed that the package was designed to minimize the number of functions that 
	need to know details of CBag&#39;s implementation. Following good practice, I wrote validation code 
	(file vCBag.cc
	<a target="Refs" href="http://okmij.org/ftp/Computation/Subtyping/References.html#Code">[Code]</a>) 
	that tests all the functions and methods of the CBag package and verifies common invariants. </p>

	<p>Suppose you are tasked with implementing a Set package. Your boss defined a set as an unordered 
	collection where each element has a single occurrence. In fact, your boss even said that a set
	<i>is a</i> bag with no duplicates. You have found my CBag package and realized that it can be used 
	with few additional changes. The definition of a Set as a Bag, with some constraints, made the decision 
	to reuse the CBag code even easier. </p>

	<table cellspacing="0" cellpadding="0" width="95%" align="right" border="0" id="table22">
		<tr>
			<td bgcolor="#e0e0e0">

			<pre>class CSet : public CBag {
 public:
  bool memberof(const int elem) const { return count(elem) &gt; 0; }

  // Overriding of CBag::put
  void put(const int elem)
  { if(!memberof(elem)) CBag::put(elem); }

  CSet * clone(void) const
  { CSet * new_set = new CSet(); *new_set += *this; return new_set; }
  CSet(void) {}
};</pre>
			</td>
		</tr>
	</table>

	<br clear="all">
&nbsp;<p>The definition of a CSet makes it possible to mix CSets and CBags, as in <code>set += bag;</code> 
	or <code>bag += set;</code> These operations are well-defined, keeping in mind that a set is a bag 
	that happens to have the count of all members exactly one. For example, <code>set += bag;</code> 
	adds all elements from a bag to a set, unless they are already present. <code>bag += set;</code> 
	is no different than merging a bag with any other bag. </p>

	<p>You too wrote a validation suite to test all CSet methods (newly defined and inherited from a 
	bag) and to verify common expected properties, e.g., <code>a+=a is a</code>. </p>

	<p>In my package, I have defined and implemented a function: </p>

	<table cellspacing="0" cellpadding="0" width="95%" align="right" border="0" id="table23">
		<tr>
			<td bgcolor="#e0e0e0">

			<pre>// A sample function. Given three bags a, b, and c, it decides
// if a+b is a subbag of c
bool foo(const CBag&amp; a, const CBag&amp; b, const CBag&amp; c)
{
  CBag &amp; ab = *(a.clone());	// Clone a to avoid clobbering it
  ab += b;			// ab is now the union of a and b
  bool result = ab &lt;= c;
  delete &amp;ab;
  return result;
}</pre>
			</td>
		</tr>
	</table>

	<br clear="all">
	It was verified in the regression test suite. You have tried this function on sets, and found it 
	satisfactory.

	<p>Later on, I revisited my code and found my implementation of foo() inefficient. Memory for the
	<code>ab</code> object is unnecessarily allocated on heap. I rewrote the function as <br>
&nbsp;</p>

	<table cellspacing="0" cellpadding="0" width="95%" align="right" border="0" id="table24">
		<tr>
			<td bgcolor="#e0e0e0">

			<pre>bool foo(const CBag&amp; a, const CBag&amp; b, const CBag&amp; c)
{
  CBag ab;
  ab += a;			// Clone a to avoid clobbering it
  ab += b;			// ab is now the union of a and b
  bool result = ab &lt;= c;
  return result;
}</pre>
			</td>
		</tr>
	</table>

	<br clear="all">
	It has exactly the same interface as the original foo(). The code hardly changed. The behavior of 
	the new implementation is also the same -- as far as I and the package CBag are concerned. Remember, 
	I have no idea that you&#39;re re-using my package. I re-ran the regression test suite with the new 
	foo(): everything tested fine.

	<p>However, when you run your code with the new implementation of foo(), you notice that something
	<i>has</i> changed! You can see this for yourself: download the complete code from
	<a target="Refs" href="http://okmij.org/ftp/Computation/Subtyping/References.html#Code">[Code]</a>.
	<code>make vCBag1</code> and <code>make vCBag2</code> run validation tests with the first and the 
	second implementations of foo(). Both tests complete successfully, with the identical results.
	<code>make vCSet1</code> and <code>make vCSet2</code> test the CSet package. The tests -- other 
	than those of foo() -- all succeed. Function foo() however yields markedly different results. It 
	is debatable which implementation of foo() gives truer results for CSets. In any case, changing 
	internal algorithms of a <i>pure</i> function foo() while keeping the same interfaces is not supposed 
	to break your code. What happened? </p>

	<p>What makes this problem more unsettling is that both you and I tried to do everything by the 
	book. We wrote a safe, typechecked code. We eschewed casts. g++ (2.95.2) compiler with flags -W 
	and -Wall issued not a single warning. Normally these flags cause g++ to become very annoying. You 
	didn&#39;t try to override methods of CBag to deliberately break the CBag package. You attempted to 
	preserve CBag&#39;s invariants (weakening a few as needed). Real-life classes usually have far more 
	obscure algebraic properties. We both wrote regression tests for our implementations of a CBag and 
	a CSet, and they passed. And yet, despite all my efforts to separate interface and implementation, 
	I failed. Should a programming language or the methodology take at least a part of the blame?
	<a target="Refs" href="http://okmij.org/ftp/Computation/Subtyping/References.html#OOP-problems">
	[OOP-problems]</a> </p>

	<p><b>Subtyping vs. Subclassing</b></p>

	<p>The problem with CSet is caused by CSet design&#39;s breaking of the Liskov Substitution Principle 
	(LSP) <a target="Refs" href="http://okmij.org/ftp/Computation/Subtyping/References.html#LSP">[LSP]</a>. 
	CSet has been declared as a <i>subclass</i> of CBag. Therefore, C++ compiler&#39;s typechecker permits 
	passing a CSet object or a CSet reference to a function that expects a CBag object or reference. 
	However, it is well known
	<a target="Refs" href="http://okmij.org/ftp/Computation/Subtyping/References.html#Subtyping-Subclassing">
	[Subtyping-Subclassing]</a> that a CSet is not a <em>subtype</em> of a CBag. The next few paragraphs 
	give a simple proof of this fact, for the sake of reference. </p>

	<p>One approach is to consider Bags and Sets as pure <i>values</i>, without any state or intrinsic 
	behavior -- just like integers are. This approach is taken in the next article,
	<a  target="_blank" href="http://okmij.org/ftp/Computation/Subtyping/Preventing-Trouble.html">Preventing-Trouble.html</a>. 
	The other point of view -- the one used in this article -- is Object-Oriented Programming, of objects 
	that encapsulate state and behavior. Behavior means an object can accept a message, send a reply 
	and possibly change its state. Let us consider a Bag and a Set separately, without regard to their 
	possible relationship. Throughout this section we use a different, concise notation to emphasize 
	the general nature of the argument. </p>

	<p>We will define a Bag as an object that accepts two messages: </p>
	<dl>
		<dt><code>(send a-Bag &#39;put x)</code> </dt>
		<dd>puts an element x into the Bag, and </dd>
		<dt><code>(send a-Bag &#39;count x)</code> </dt>
		<dd>gives the count of occurrences of x in the Bag (without changing a-Bag&#39;s state). </dd>
	</dl>
	Likewise, a Set is defined as an object that accepts two messages:
	<dl>
		<dt><code>(send a-Set &#39;put x)</code> </dt>
		<dd>puts an element x into a-Set unless it was already there, </dd>
		<dt><code>(send a-Set &#39;count x)</code> </dt>
		<dd>gives the count of occurrences of x in a-Set (which is always either 0 or 1). </dd>
	</dl>
	Let&#39;s consider a function

	<table cellspacing="0" cellpadding="0" width="95%" align="right" border="0" id="table25">
		<tr>
			<td bgcolor="#e0e0e0">

			<pre>(define (fnb bag)
   (send bag &#39;put 5)
   (send bag &#39;put 5)
   (send bag &#39;count 5))</pre>
			</td>
		</tr>
	</table>

	<br clear="all">
	The behavior of this function can be summed as follows: given a Bag, the function adds two elements 
	into it and returns<br>
&nbsp;&nbsp;&nbsp; <code>(+ 2 (send orig-bag &#39;count 5))</code>

	<p>Technically you can pass to <code>fnb</code> a Set object as well. Just as a Bag, a Set object 
	accepts messages <code>put</code> and <code>count</code>. However applying <code>fnb</code> to a 
	Set object will break the function&#39;s post-condition, which stated above. Therefore, passing a set 
	object where a bag was expected changes behavior of some program. According to the Liskov Substitution 
	Principle (LSP), a Set is not substitutable for a Bag -- a Set cannot be a <i>subtype</i> of a Bag.
	</p>

	<p>Let&#39;s consider a function </p>

	<table cellspacing="0" cellpadding="0" width="95%" align="right" border="0" id="table26">
		<tr>
			<td bgcolor="#e0e0e0">

			<pre>(define (fns set)
   (send set &#39;put 5)
   (send set &#39;count 5))</pre>
			</td>
		</tr>
	</table>

	<br clear="all">
	The behavior of this function is: given a Set, the function adds an element into it and returns 
	1. If you pass to this function a bag (which -- just as a set -- replies to messages <code>put</code> 
	and <code>count</code>), the function <code>fns</code> may return a number greater than 1. This 
	will break <code>fns</code>&#39;s contract, which promised always to return 1.

	<p>Therefore, from the OO point of view, neither a Bag nor a Set are a subtype of the other. This 
	is the crux of the problem. Bag and Set only <i>appear</i> similar. The interface or an implementation 
	of a Bag and a Set appear to invite <i>subclassing</i>of a Set from a Bag (or vice versa). Doing 
	so however will violate the LSP -- and you have to brace for very subtle errors. The previous section 
	intentionally broke the LSP to demonstrate how insidious the errors are and how difficult it may 
	be to find them. Sets and Bags are very simple types, far simpler than the ones you deal with in 
	a production code. Alas, LSP when considered from an OOP point of view is undecidable. You <i>cannot</i> 
	count on a compiler for help in pointing out an error. You cannot rely on regression tests either. 
	It&#39;s manual work -- you have to <i>see</i> the problem
	<a target="Refs" href="http://okmij.org/ftp/Computation/Subtyping/References.html#OOP-problems">
	[OOP-problems]</a>. </p>

	<p><b>Subtyping and Immutability</b></p>
	One may claim that &quot;A Set *is not a* Bag, but an ImmutableSet *is an* ImmutableBag.&quot; That is not 
	correct. An immutability per se does not confer subtyping to &quot;derived&quot; classes of data. As an example, 
	consider a variation of the previous argument. We will use a C++ syntax for a change. The examples 
	will hold if re-written in Java, Haskell, Self or any other language with a native or emulated OO 
	system. <br>
&nbsp;<table cellspacing="0" cellpadding="0" width="95%" align="right" border="0" id="table27">
		<tr>
			<td bgcolor="#e0e0e0">

			<pre>class BagV {
  virtual BagV put(const int) const;
  int count(const int) const;
  ... // other similar const members
};
 
class SetV {
  virtual SetV put(const int) const;
  int count(const int) const;
  ... // other similar const members
};</pre>
			</td>
		</tr>
	</table>

	<br clear="all">
&nbsp;

	<p>Instances of BagV and SetV classes are immutable, yet the classes are not subtypes of each other. 
	To see that, let us consider a polymorphic function </p>

	<table cellspacing="0" cellpadding="0" width="95%" align="right" border="0" id="table28">
		<tr>
			<td bgcolor="#e0e0e0">

			<pre>template &lt;typename T&gt; int f(const T&amp; t)
{ return t.put(1).count(1); }</pre>
			</td>
		</tr>
	</table>

	<br clear="all">
	Over a set of BagV instances, the behavior of this function can be represented by an invariant<br>
&nbsp;&nbsp;&nbsp; <code>f(bag) == 1 + bag.count(1)</code>

	<p>If we take an object <code>asetv = SetV().put(1)</code> and pass it to <code>f()</code>, the 
	invariant above will be broken. Therefore, by LSP, a SetV is not substitutable for BagV: a SetV
	<i>is not a</i> BagV. </p>

	<p>In other words, if one defines </p>

	<table cellspacing="0" cellpadding="0" width="95%" align="right" border="0" id="table29">
		<tr>
			<td bgcolor="#e0e0e0">

			<pre>int fb(const BagV&amp; bag) { return bag.put(1).count(1); }</pre>
			</td>
		</tr>
	</table>

	<br clear="all">
	he can potentially pass a SetV instance to it: e.g., either by making SetV a subclass of BagV, or 
	by <code>reinterpret_cast&lt;const BagV&amp;&gt;(aSetV)</code>. Doing so will generate no overt error; yet 
	this will break fb()&#39;s invariant and alter program&#39;s behavior in unpredictable ways. A similar argument 
	will show that BagV is not a subtype of SetV.

	<p>C++ objects are record-based. Subclassing is a way of extending records, with possibly altering 
	some slots in the parent record. Those slots must be designated as modifiable by a keyword virtual. 
	In this context, prohibiting mutation and overriding makes subclassing imply subtyping. This was 
	the reasoning behind BRules [<a  target="_blank" href="http://okmij.org/ftp/Computation/Subtyping/Preventing-Trouble.html">Preventing-Trouble.html</a>].
	</p>

	<p>However merely declaring the state of an object immutable is not enough to guarantee that derivation 
	leads to subtyping: An object can override parent&#39;s behavior without altering the parent. This is 
	easy to do when an object is implemented as a functional closure, when a handler for an incoming 
	message is located with the help of some kind of reflexive facilities, or in prototype-based OO 
	systems. Incidently, if we do permit a derived object to alter its base object, we implicitly allow 
	behavior overriding. For example, an object <code>A</code> can react to a message <code>M</code> 
	by forwarding the message to an object <code>B</code> stored in <code>A</code>&#39;s slot. If an object
	<code>C</code> derived from <code>A</code> alters that slot it hence overrides <code>A</code>&#39;s 
	behavior with respect to <code>M</code>. </p>

	<p>For example, <a  target="_blank" href="http://pobox.com/~oleg/ftp/Scheme/index.html#pure-oo">http://pobox.com/~oleg/ftp/Scheme/index.html#pure-oo</a> 
	implements a purely functional OO system. It supports objects with an identity, state and behavior, 
	inheritance and polymorphism. <i>Everything</i> in that system is immutable. And yet it is possible 
	to define something like a BagV, and derive SetV from it by overriding a <code>put</code> message 
	handler. Acting this way is bad and invites trouble as this breaks the LSP as shown earlier. Yet 
	it is possible. This example shows that immutability per se does not turn object derivation into 
	subtyping. </p>

	<p>The present page is a compilation and extension of two articles posted on comp.object, comp.lang.functional, 
	comp.lang.c++.moderated newsgroups on Jun 18 and Jul 14, 2000. <br>
	Discussion thread:
	<a  target="_blank" href="http://www.deja.com/viewthread.xp?AN=644379349.1&search=thread&recnum=%3c8katsh$fmf$1@nnrp1.deja.com%3e%231/5&group=comp.object&frpage=viewthread.xp">
	http://www.deja.com/viewthread.xp?AN=644379349.1&amp;search=thread&amp;recnum=%3c8katsh$fmf$1@nnrp1.deja.com%3e%231/5&amp;group=comp.object&amp;frpage=viewthread.xp</a>&nbsp;
	<br>
	<b><br>
	Acknowledgment</b></p>
	Andy Gaynor has asked the right questions. This article is merely an answer.
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2007_0501_subtyping_subclassing_and__trouble_with_oop"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2006_1215_the__mythical_open_source_miracle" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2006_0924_dreamsongs_essays__downloads"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Dec 15, 2006]
<a target="_blank" href="http://www.computerworld.com.au/index.php/id;884880645;fp;4194304;fpid;1">The 
mythical open source miracle</a> by Neil McAllister</h4>

<h5>Actually Spolsky does not understand the role of scripting languages. But hi is right of target 
with his critique of OO. Object oriented programming is no silver bullet. </h5>
<blockquote>

	<h6>Dec 14, 2006 |
	<a target="_blank" href="http://www.computerworld.com.au/index.php/authid;180962748">InfoWorld</a>
	</h6>

	<p>Joel Spolsky is one of our most celebrated pundits on the practice of software development, and 
	he&#39;s full of terrific insight. In a recent blog post, he decries the fallacy of
	<a target="_blank" href="http://www.joelonsoftware.com/items/2006/12/05.html">&quot;Lego programming&quot;</a> 
	-- the all-too-common assumption that sophisticated new tools will make writing applications as 
	easy as snapping together children&#39;s toys. It simply isn&#39;t so, he says -- despite the fact that 
	people have been claiming it for decades -- because the most important work in software development 
	happens before a single line of code is written. </p>

	<p>By way of support, Spolsky reminds us of a quote from the most celebrated pundit of an earlier 
	generation of developers. In his 1987 essay
	<a target="_blank" href="http://www-inst.eecs.berkeley.edu/~maratb/readings/NoSilverBullet.html">
	&quot;No Silver Bullet,&quot;</a> Frederick P. Brooks wrote, <font color="#FF0000"><i><b>&quot;The essence of a 
	software entity is a construct of interlocking concepts ... I believe the hard part of building 
	software to be the specification, design, and testing of this conceptual construct, not the labor 
	of representing it and testing the fidelity of the representation ... If this is true, building 
	software will always be hard. There is inherently no silver bullet.&quot; </b></i></font></p>

	<p>As Spolsky points out, in the 20 years since Brooks wrote &quot;No Silver Bullet,&quot; countless products 
	have reached the market heralded as the silver bullet for effortless software development. Similarly, 
	in the 30 years since Brooks published &quot;
	<a target="_blank" href="http://en.wikipedia.org/wiki/The_Mythical_Man-Month">The Mythical Man-Month</a>&quot; 
	-- in which, among other things, he debunks the fallacy that if one programmer can do a job in ten 
	months, ten programmers can do the same job in one month -- product managers have continued to buy 
	into various methodologies and tricks that claim to make running software projects as easy as stacking 
	Lego bricks. </p>

	<p><font color="#FF0000"><i><b>Don&#39;t you believe it. If, as Brooks wrote, the hard part of software 
	development is the initial design, then no amount of radical workflows or agile development methods 
	will get a struggling project out the door, any more than the latest GUI rapid-development toolkit 
	will. </b></i></font></p>

	<p>And neither will open source. Too often, commercial software companies decide to turn over their 
	orphaned software to &quot;the community&quot; --
	<a target="_blank" href="http://www.onlamp.com/pub/a/onlamp/2006/01/12/no_oss_community.html">if 
	such a thing exists</a> -- in the naive belief that open source will be a miracle cure to get a 
	flagging project back on track. This is just another fallacy, as history demonstrates. </p>

	<p>In 1998, Netscape released the source code to its Mozilla browser to the public to much fanfare, 
	but only lukewarm response from developers. As it turned out, the Mozilla source was much too complex 
	and of too poor quality for developers outside Netscape to understand it. As Jamie Zawinski
	<a target="_blank" href="http://www.jwz.org/gruntle/nomo.html">recounts,</a> the resulting decision 
	to rewrite the browser&#39;s rendering engine from scratch derailed the project anywhere from six to 
	ten months. </p>

	<p>This is a classic example of the fallacy of the mythical man-month. The problem with the Mozilla 
	code was poor design, not lack of an able workforce. Throwing more bodies at the project didn&#39;t 
	necessarily help; it may have even hindered it. And while implementing a community development process 
	may have allowed Netscape to sidestep its own internal management problems, it was certainly no 
	silver bullet for success. </p>

	<p>The key to developing good software the first time around is doing the hard work at the beginning: 
	good design, and rigorous testing of that design. Fail that, and you&#39;ve got no choice but to take 
	the hard road. As Brooks observed all those years ago, successful software will never be easy. No 
	amount of open source process will change that, and to think otherwise is just more Lego-programming 
	nonsense.</p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2006_1215_the__mythical_open_source_miracle"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2006_0924_dreamsongs_essays__downloads" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2006_0924_objects_have_failed"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Sep 24, 2006] <a target="_blank" href="http://www.dreamsongs.com/Essays.html">Dreamsongs Essays 
Downloads</a></h4>
<blockquote>

	<p><b>Resolved: Objects Have Failed</b></p>

	<p>I participated in a debate on the question &quot;Objects Have Failed&quot; at OOPSLA 2002 in Seattle, Washington. 
	My teammate was Brian Foote, and our opponents were Guy L. Steele Jr. and James Noble. My opening 
	remarks were scripted, as were Guy Steele&#39;s, and my rebuttals were drawn from an extensive set of 
	notes.</p>
	<ul>

		<li>rpg&#39;s Opening Remarks [<a target="_blank" href="http://www.dreamsongs.com/ObjectsHaveFailedNarrative.html">html</a>]
		</li>

		<li>gls&#39;s Opening Remarks [<a target="_blank" href="http://www.dreamsongs.com/ObjectsHaveNotFailedNarr.html">html</a>]
		</li>

		<li>Discursive Notes [1.1 mb
		<a target="_blank" href="http://www.dreamsongs.com/Files/ObjectsHaveFailed.pdf">pdf</a> ]
		</li>

		<li>Notes as Slides [7.1 mb
		<a target="_blank" href="http://www.dreamsongs.com/Files/ObjectsHaveFailedSlides.pdf">pdf</a> 
		] </li>
	</ul>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2006_0924_dreamsongs_essays__downloads"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2006_0924_objects_have_failed" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2006_0214_oop_criticism"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Sep 24, 2006]
<a target="_blank" href="http://www.dreamsongs.com/ObjectsHaveFailedNarrative.html">Objects Have Failed</a><i> 
by Richard P. Gabriel</i></h4>

<h5>&quot;Obsessive embrace has spawned a search for purity that has become an ideological weapon, promoting 
an incremental advance as the ultimate solution to our software problems. &quot; ...&nbsp; &quot;Needless to say, 
object-orientation provides an important lens through which to understand and fashion systems in the 
new world, but it simply cannot be the only lens. &quot; ... &quot;And as a result we find that object-oriented 
languages have succumbed to static thinkers who worship perfect planning over runtime adaptability, 
early decisions over late ones, and the wisdom of compilers over the cleverness of failure detection 
and repair.&quot;</h5>
<blockquote>

	<h6>November 6, 2002</h6>

	<p><i>Opening remarks </i></p>

	<p>What can it mean for a programming paradigm to fail? A paradigm fails when the narrative it embodies 
	fails to speak truth or when its proponents embrace it beyond reason. The failure to speak truth 
	centers around the changing needs of software in the 21st century and around the so-called improvements 
	on OO that have obliterated its original benefits. <font color="#FF0000"><i><b>Obsessive embrace 
	has spawned a search for purity that has become an ideological weapon, promoting an incremental 
	advance as the ultimate solution to our software problems. </b></i></font>The effect has been to 
	brainwash people on the street. The statement &quot;everything is an object&quot; says that OO is universal, 
	and the statement &quot;objects model the real world&quot; says that OO has a privileged position. These are 
	very seductive invitations to a totalizing viewpoint. The result is to starve research and development 
	on alternative paradigms.</p>

	<p>Someday, the software we have already written will be a set of measure 0. We have lived through 
	three ages of computing—the first was machine coding; the second was symbolic assemblers, interpreter 
	routines, and early compilers; and the third was imperative, procedural, and functional programming, 
	and compiler-based languages. Now we are in the fourth: object-oriented programming. These first 
	four ages featured single-machine applications. Even though such systems will remain important, 
	increasingly our systems will be made up of dozens, hundreds, thousands, or millions of disparate 
	components, partial applications, services, sensors, and actuators on a variety of hardware, written 
	by a variegated set of developers, and it won’t be incorrect to say that no one knows how it all 
	works. In the old world, we focussed on efficiency, resource limitations, performance, monolithic 
	programs, standalone systems, single author programs, and mathematical approaches. In the new world 
	we will foreground robustness, flexibility, adaptation, distributed systems, multiple-author programs, 
	and biological metaphors for computing.</p>

	<p><font color="#FF0000"><i><b>Needless to say, object-orientation provides an important lens through 
	which to understand and fashion systems in the new world, but it simply cannot be the only lens.</b></i>
	</font>In future systems, unreliability will be common, complexity will be out of sight, and anything 
	like carefully crafted precision code will be unrealistic. It’s like a city: Bricks are important 
	for building part of some buildings, but the complexity and complicated way a variety of building 
	materials and components come together under the control of a multitude of actors with different 
	cultures and goals, talents and proclivities means that the kind of thinking that goes into bricks 
	will not work at the scale of the city. Bricks are just too limited, and the circumstances where 
	they make sense are too constrained to serve as a model for building something as diverse and unpredictable 
	as a city. And further, the city itself is not the end goal, because the city must also—in the best 
	case—be a humane structure for human activity, which requires a second set of levels of complexity 
	and concerns. Using this metaphor to talk about future computing systems, it’s fair to say that 
	OO addresses concerns at the level of bricks.</p>

	<p>The modernist tendency in computing is to engage in totalizing discourse in which one paradigm 
	or one story is expected to supply all in every situation. Try as they might, OO’s promoters cannot 
	provide a believable modernist grand narrative to the exclusion of all others. OO holds no privileged 
	position. So instead of Java for example embracing all the components developed elsewhere, its proponents 
	decided to develop their own versions so that all computing would be embraced within the Java narrative.</p>

	<p>Objects, as envisioned by the designers of languages like Smalltalk and Actors—long before C++ 
	and Java came around— were for modeling and building complex, dynamic worlds. Programming environments 
	for languages like Smalltalk were written in those languages and were extensible by developers. 
	Because the philosophy of dynamic change was part of the post-Simula OO worldview, languages and 
	environments of that era were highly dynamic.</p>

	<p>But with C++ and Java, the dynamic thinking fostered by object-oriented languages was nearly 
	fatally assaulted by the theology of static thinking inherited from our mathematical heritage and 
	the assumptions built into our views of computing by Charles Babbage whose factory-building worldview 
	was dominated by omniscience and omnipotence.</p>

	<p><font color="#FF0000"><i><b>And as a result we find that object-oriented languages have succumbed 
	to static thinkers who worship perfect planning over runtime adaptability, early decisions over 
	late ones, and the wisdom of compilers over the cleverness of failure detection and repair.</b></i></font></p>

	<p>Beyond static types, precise interfaces, and mathematical reasoning, we need self-healing and 
	self-organizing mechanisms, checking for and responding to failures, and managing systems whose 
	overall complexity is beyond the ken of any single person.</p>

	<p>One might think that such a postmodern move would have good consequences, but unlike Perl, the 
	combination was not additive but subtractive—as if by undercutting what OO was, OO could be made 
	more powerful. This may work as a literary or artistic device, <font color="#FF0000"><i><b>but the 
	idea in programming is not to teach but to build.</b></i></font></p>

	<p>The apparent commercial success of objects and our love affair with business during the past 
	decade have combined to stifle research and exploration of alternative language approaches and paradigms 
	of computing. University and industrial research communities retreated from innovating in programming 
	languages in order to harvest the easy pickings from the OO tree. The business frenzy at the end 
	of the last century blinded researchers to diversity of ideas, and they were into going with what 
	was hot, what was uncontroversial. If ever there was a time when Kuhn’s normal science dominated 
	computing, it was during this period.</p>

	<p>My own experience bears this out. Until 1995, when I went back to school to study poetry, my 
	research career centered on the programming language, Lisp. When I returned in 1998, I found that 
	my research area had been eliminated. I was forced to find new ways to earn a living within the 
	ecology created by Java, which was busily recreating the computing world in its own image.</p>

	<p>Smalltalk, Lisp, Haskell, ML, and other languages languish while C++, Java, and their near-clone 
	C# are the only languages getting attention. Small languages like Tcl, Perl, and Python are gathering 
	adherents, but are making no progress in language and system design at all.</p>

	<p>Our arguments come in several flavors:</p>
	<ol>

		<li>The object-oriented approach does not adequately address the computing requirements of the 
		future. </li>

		<li>Object-oriented languages have lost the simplicity — some would say purity — that made them 
		special and which were the source of their expressive and development power. </li>

		<li>Powerful concepts like encapsulation were supposed to save people from themselves while 
		developing software, but encapsulation fails for global properties or when software evolution 
		and wholesale changes are needed. Open Source handles this better. It’s likely that modularity—keeping 
		things local so people can understand them—is what’s really important about encapsulation.
		</li>

		<li><font color="#FF0000"><i><b>Objects promised reuse, and we have not seen much success.</b></i></font>
		</li>

		<li>Despite the early clear understanding of the nature of software development by OO pioneers, 
		the current caretakers of the ideas have reverted to the incumbent philosophy of perfect planning, 
		grand design, and omniscience inherited from Babbage’s theology. </li>

		<li>The over-optimism spawned by objects in the late 1990s led businesses to expect miracles 
		that might have been possible with objects unpolluted by static thinking , and when software 
		developers could not deliver, the outrageous business plans of those businesses fell apart, 
		and the result was our current recession. </li>

		<li><font color="#FF0000"><i><b>Objects require programming by creating communicating entities, 
		which means that programming is accomplished by building structures rather than by linguistic 
		expression and description through form, and this often leads to a mismatch of language to problem 
		domain. </b></i></font></li>

		<li>Object design is like creating a story in which objects talk and interact with each other, 
		leading people to expect that learning object-oriented programming is easy, when in fact it 
		is as hard as ever. Again, business was misled. </li>

		<li>People enthused by objects hogged the road, would not get out of the way, would not allow 
		alternatives to be explored—not through malice but through exuberance—and now resources that 
		could be used to move ahead are drying up. But sometimes this exuberance was out-and-out lying 
		to push others out of the way. </li>
	</ol>

	<p>But in the end, we don’t advocate changing the way we work on and with objects and object-oriented 
	languages. Instead, we argue for diversity, for work on new paradigms, for letting a thousand flowers 
	bloom. Self-healing, self-repair, massive and complex systems, self-organization, adaptation, flexibility, 
	piecemeal growth, statistical behavior, evolution, emergence, and maybe dozens of other ideas and 
	approaches we haven’t thought of—including new physical manifestations of non-physical action—should 
	be allowed and encouraged to move ahead.</p>

	<p>This is a time for paradigm definition and shifting. It won’t always look like science, won’t 
	always even appear to be rational; papers and talks explaining and advocating new ideas might sound 
	like propaganda or fiction or even poetry; narrative will play a larger role than theorems and hard 
	results. This will not be normal science.</p>

	<p><font color="#FF0000"><i><b>In the face of all this, it’s fair to say that objects have failed.</b></i></font></p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2006_0924_objects_have_failed"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2006_0214_oop_criticism" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2006_0214_cargo_cult_software_engineering"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Feb 14, 2006]
<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/oopbad.htm">OOP Criticism</a> 
Object Oriented Programming Oversold by&nbsp; B. Jacobs.&nbsp; OOP criticism and OOP problems.&nbsp; 
The emperor has no clothes! Reality Check 101. Snake OOil. </h4>
<blockquote>

	<h6>5/14/2005 </h6>
	<font color="#006000">

	<p><b>OOP Myths Debunked: </b></p>
</blockquote>
</font>
<ul>

	<li>Myth: OOP is a proven general-purpose technique </li>

	<li>Myth: OOP models the real world better </li>

	<li>Myth: OOP makes programming more visual </li>

	<li>Myth: OOP makes programming easier and faster </li>

	<li>Myth: OOP eliminates the &quot;complexity&quot; of &quot;case&quot; or &quot;switch&quot; statements </li>

	<li>Myth: OOP reduces the number of places that require changing </li>

	<li>Myth: OOP increases reuse (recycling of code) </li>

	<li>Myth: Most things fit nicely into hierarchical taxonomies </li>

	<li>Myth: Sub-typing is a stable way to model differences </li>

	<li>Myth: Self-handling nouns are more useful than self-handling verbs </li>

	<li>Myth: Most operations have one natural &quot;primary noun&quot; </li>

	<li>Myth: OOP does automatic garbage-collection better </li>

	<li>Myth: Procedural cannot do components well </li>

	<li>Myth: OO databases can better store large, multimedia data </li>

	<li>Myth: OODBMS are overall faster than RDBMS </li>

	<li>Myth: OOP better hides persistence mechanisms </li>

	<li>Myth: C and Pascal are the best procedural can get </li>

	<li>Myth: SQL is the best relational language </li>

	<li>Myth: OOP would have prevented more Y2K problems </li>

	<li>Myth: OOP &quot;does patterns&quot; better </li>

	<li>Myth: Only OOP can &quot;protect data&quot; </li>

	<li>Myth: Implementation changes significantly more often than interfaces </li>

	<li>Myth: Procedural/Relational ties field types and sizes to the code more </li>

	<li>Myth: Procedural cannot extend compiled portions very well </li>

	<li>Myth: No procedural language can re-compile at the routine level </li>

	<li>Myth: Procedural/Relational programs cannot &quot;factor&quot; as well </li>

	<li>Myth: OOP models human thought better (Which human?) </li>

	<li>Myth: OOP is more &quot;modular&quot; </li>

	<li>Myth: OOP divides up work better </li>

	<li>Myth: OOP &quot;hides complexity&quot; better </li>

	<li>Myth: OOP better models spoken language </li>

	<li>Myth: OOP is &quot;better abstraction&quot; </li>

	<li>Myth: OOP reduces &quot;coupling&quot; </li>

	<li>Myth: OOP does multi-tasking better </li>

	<li>Myth: OOP scales better </li>

	<li>Myth: OOP is more &quot;event driven&quot; </li>

	<li>Myth: Most programmers prefer OOP </li>

	<li>Myth: OOP manages behavior better </li>
</ul>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2006_0214_oop_criticism"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2006_0214_cargo_cult_software_engineering" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2006_0214_incipient_thoughts__throw_some_java_salt_over_your_shoulder"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>
<a onmousedown="return clk(this,'res',50)" href="http://www.informit.com/articles/article.asp?p=99980&seqNum=2">
Cargo Cult Software Engineering</a> By Steve McConnell.&nbsp; </h4>

<h5>Software-engineering has two kinds of cargo-cult; slavish adherence to process without regard to 
the effect on product, and reliance on personal heroics, again without regard to product. In both cases, 
organizations try to mimic programming style/paradigm, but only mimic the external appearance&nbsp; 
without understanding real programming techniques and ideas behind the technology.</h5>
<blockquote>

	<p><font size="2">The real difference is not which style is chosen, but what education, training, 
	and understanding is brought to bear on the project. Rather than debating process vs. commitment, 
	we should be looking for ways to raise the average level of developer and manager competence. That 
	will improve our chances of success regardless of which development style we choose. </font></p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2006_0214_cargo_cult_software_engineering"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2006_0214_incipient_thoughts__throw_some_java_salt_over_your_shoulder" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2004_1115_smalltalk_tidbits_industry_rants_cargo_cult_coding_practices"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4><a target="_blank" href="http://bossavit.com/thoughts/archives/000776.html">Incipient(thoughts) 
Throw some Java salt over your shoulder</a></h4>
<blockquote>

	<p><font size="2" face="Arial">I&#39;m fairly sure you could accurately gauge the maturity of a programming 
	team by the amount of superstition in the source code they produce. Code superstitions are a milder 
	form of <a target="_blank" href="http://fishbowl.pastiche.org/2004/10/13/cargo_cult_programming">
	cargo cult</a> software development, in which you find people writing code constructs that have 
	no conceivable value with respect to the functions that the code is meant to fulfill. </font>
	</p>

	<p><font size="2" face="Arial">A recent conversation reminded me of an example I find particularly 
	disturbing. Sample code for dealing with JDBC is particularly prone to being littered with this 
	particular error, as shown below. (I suspect that is not coincidental; I&#39;ll be coming back to that.) 
	I have elided most braces out for clarity and terseness - imagine that this is a cross between Java 
	and Python: </font></p>

	<pre>import java.sql.*; 

public class JdbcSample {
  public static void main(String[] args) {
    Connection conn = null;
    try
      conn = DriverManager.getConnection(&quot;jdbc:someUrl&quot;);
      // ...more JDBC stuff...
    catch (SQLException ex)
      // Too often that is silently ignored, but that&#39;s another blog entry
    finally
      if (conn != null)
        try
          conn.close();
        catch (SQLException sqlEx)
      conn = null; 
  }</pre>

	<p><font size="2" face="Arial">The &quot;superstition&quot; part is that setting the connection to null can 
	have absolutely no useful effect; being a local variable, &quot;conn&quot; will become eligible for garbage 
	collection as soon as it goes out of scope anyway, which the most rudimentary analysis of flow control 
	reveals it will immediately after being set to null. </font></p>

	<p><font size="2" face="Arial">I am always particularly interested in finding out what goes on in 
	the minds of programmers who write this kind of thing, because that will sometimes reveal the roots 
	of the superstition. Most of the time, though, if you raise question in a design review the programmer 
	will say something like &quot;I copied and pasted it from sample code&quot;. This is how the superstitions 
	spread - and it&#39;s also a red flag with respect to the team&#39;s practice maturity - but rarely an occasion 
	to gain insight into why the superstition took hold, which is what you&#39;ll need to know in &quot;remedial&quot; 
	training. </font></p>

	<p><font size="2" face="Arial">Now, the &quot;null&quot; concept, obvious as it seems, is a likely place for 
	superstitions to accrete around. If you look closely, &quot;null&quot; is nothing but obvious. Comparing Java 
	and Smalltalk, for instance, we find that they differ radically with respect to calling instance 
	methods on null, or &quot;nil&quot; as it&#39;s called in Smalltalk; &quot;nil&quot; does have some instance methods you 
	can call. Also, what is the type of the &quot;null&quot; value in Java ? It is a special type called &quot;the 
	null type&quot;, which looks like a sensible answer but incidentally breaks the consistency of the type 
	system; the only types which are assignable to variables are the type of the variable or subtypes 
	of that type, so &quot;null type&quot; should be a subclass of every Java class. (It actually works that way 
	in Eiffel, as Nat Pryce reminds me - see comments.) </font></p>

	<p><font size="2" face="Arial">See also
	<a target="_blank" href="http://jroller.com/page/softmotion/20041001#when_ignorance_is_my_best">
	here</a> for another example of a null-related Java superstition, also surprisingly common, as you 
	can verify by Googling for &quot;equals null&quot;. </font></p>

	<p><font size="2" face="Arial">In the case of JDBC, I would bet that idioms of resource allocation 
	and deallocation inherited from non-garbage collected languages, like C, were the main force in 
	establishing the superstition. Even people new to Java get used to not calling &quot;dispose&quot; or &quot;delete&quot; 
	to deallocate objects, but unfortunately the design of the JDBC &quot;bridges&quot; between the object and 
	relational worlds suffer from a throwback to idioms of explicit resource allocation/deallocation.
	</font></p>

	<p><font size="2" face="Arial">Owing to what many see as a major design flaw in Java, &quot;going out 
	of scope&quot; cannot be relied on as an indicator that a resource is no longer in use, either, so whenever 
	they deal with JDBC Java programmers are suddenly thrown back into a different world, one where 
	deallocation is something to think about, like not forgetting your keys at home. And so, in precisely 
	the same way as I occasionally found myself patting my pockets to check for home keys when I left 
	the <i>office</i>, our fingers reflexively type in the closest equivalent we find in Java to an 
	explicit deallocation - setting to null. </font></p>

	<p><font size="2" face="Arial">You may object that the setting-to-null superstition is totally harmless. 
	So is throwing salt over your shoulder. While this may be true of <i>one</i> particular superstition, 
	I would be particularly concerned about a team which had many such habits, just like you wouldn&#39;t 
	want to trust much of importance your batty old aunt who avoids stepping on cracks, stays home on 
	Fridays, crosses herself on seeing a black cat, but always sends you candy for Christmas. </font>
	</p>
	<font size="2" face="Arial">Posted by Morendil at November 15, 2004 04:57 PM </font>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2006_0214_incipient_thoughts__throw_some_java_salt_over_your_shoulder"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2004_1115_smalltalk_tidbits_industry_rants_cargo_cult_coding_practices" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2000_00_november_15_2004_19_23_32__est"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>[Nov 15, 2004]
<a target="_blank" href="http://www.cincomsmalltalk.com/blog/blogView?showComments=true&entry=3277998437">
Smalltalk Tidbits, Industry Rants cargo cult coding practices</a></h4>
<blockquote>

	<p><font face="Arial">
	<a target="_blank" href="http://bossavit.com/thoughts/archives/000776.html"><font size="2">Laurent 
	Bossavit</font></a><font size="2"> explains the notion of &quot;Cargo Cult&quot; programming - the example 
	being setting a temporary variable to null (i.e., one that is going out of scope)</font></font></p>

	<p><font size="2" face="Arial">You may object that the setting-to-null superstition is totally harmless. 
	So is throwing salt over your shoulder. While this may be true of one particular superstition, I 
	would be particularly concerned about a team which had many such habits, just like you wouldn&#39;t 
	want to trust much of importance your batty old aunt who avoids stepping on cracks, stays home on 
	Fridays, crosses herself on seeing a black cat, but always sends you candy for Christmas.</font></p>

	<p><font size="2" face="Arial">What superstitious coding practices does your group have?</font></p>

	<h3><font size="2" face="Arial">Comments</font></h3>

	<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2004_1115_smalltalk_tidbits_industry_rants_cargo_cult_coding_practices"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_november_15_2004_19_23_32__est" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2000_00_november_16_2004_10_08_33__est"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4><font size="2" face="Arial">null helps GC yes? no? [john mcintosh] November 15, 2004 19:23:32 
	EST</font></h4>

	<p><font size="2" face="Arial">I once had a fellow phone me from Hong Kong who explained a performance 
	problem they were having. Seems they at the end of each method, and in each &quot;destroy&quot; method for 
	a class (used to to destroy instances), they would set all the variables to NULL. The best was of 
	course iterating over thousands of array elements, setting them to NULL since they felt this was 
	helping the GC find NULL (garbaged) variables faster. Once they stopped doing this why windows just 
	snapped closed.... </p>
	</font>

	<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2000_00_november_15_2004_19_23_32__est"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_november_16_2004_10_08_33__est" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2000_00_cargo_cults__in_java"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4><font size="2" face="Arial">Empty Java constructor [Jason Dufair] November 16, 2004 10:08:33 
	EST</font></h4>

	<p><font size="2" face="Arial">I&#39;m on a team doing Java right now. I see a lot of empty Java constructors. 
	Being a Smalltalker making a living doing Java, I figured they must be there for a reason. Come 
	to find out an empty constructor just calls the super&#39;s constructor. As if it weren&#39;t there in the 
	first place. Whee! </font></p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2000_00_november_16_2004_10_08_33__est"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_cargo_cults__in_java" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2000_00_beware_of_cargo_cult__coding"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>&nbsp;<a target="_blank" href="http://www.ics.ltsn.ac.uk/events/jicc8/fletcher.pdf">Cargo Cults 
in Java</a>&nbsp; by Gordon Fletcher University of Salford</h4>
<blockquote>
	[PDF]<font size="2" face="Arial">This paper is a personal account of my experience of teaching Java 
	programming to undergraduate and postgraduate students. These students enter their respective subjects 
	with no previous Java programming knowledge. However, the undergraduate students have previous experience 
	with Visual Basic programming. In contrast, the postgraduate students are enrolled in a “conversion” 
	course which, in most cases, means that they were unfamiliar with any form of programming language 
	or, in some cases, some core information technology skills. Irrespective of these differences,
	<i><b>I have witnessed how both groups independently develop, what can be described as, a trade 
	based culture with similarities to ‘cargo cults’ around the Java language. </b></i>This anthropological 
	term provides a useful terms of reference as the focus of programming activity for many students 
	increasingly centres upon the imitation of code gathered from the lecturer or, in some cases, each 
	other. This is particularly evident as project deadlines approach. In extreme examples of this cargo 
	cult fever, students will discard potentially strong project developments that incorporate many 
	features of good software design in favour of inelegant and cobbled together code on the single 
	criteria of better functionality.</font><p><font size="2" face="Arial">In this paper I use the concept 
	of the cargo cult to frame the differing expectations surrounding “learning Java” that are held 
	by students and their lecturer. I draw upon my own observations and experiences as the teacher in 
	these learning environments and upon feedback from my most recent cohort of undergraduate students 
	undertaking an BSc(Hons) programme within a UK university. The student feedback is drawn from a 
	questionnaire containing six questions relating to their experiences and expectations regarding 
	a Java programming subject. The definition and description of the cargo cult is also used to consider 
	how this relationship can be established in a way that encourages positive learning outcomes through 
	the obligations and reciprocation associated with gifts – in this case, clearly labeled gifts of 
	code. <i><b>The cargo cult and the erroneous form of thinking associated with it provide a useful 
	framework for understanding the teaching and learning environment in which I taught Java.</b></i> 
	In this way the interactions and motivation of students and the lecturers who ultimately share the 
	common goal of obtaining their academic success can be scrutinized with the aim of improving this 
	experience for all those involved. <i><b>The cargo cult is not, however, ‘simply’ an anachronistic 
	analogy drawn from social anthropology. Cargo cult thinking has been identified within contemporary 
	culture as readily as tribal cultures and with equal significance</b></i> (Hirsch 2002; Cringely 
	2001, Fitzgerald 1999; Feynman 1974).</font> </p>

	<p><b><i><font size="2" face="Arial">2. Cargo Cult Thinking</font></i><font size="2" face="Arial">
	</font></b></p>

	<p><font size="2" face="Arial">It is important to acknowledge that cargo cult thinking is not necessarily 
	the ‘wrong’ way of thinking or that this paper seeks to castigate students’ study practices. Cargo 
	cult thinking is based, in part, on conclusions drawn from only partially observed phenomena. In 
	many respects this paper is a reflexive exercise regarding my own teaching practices and an examination 
	of the ways in which cargo cult thinking can be employed to achieve positive learning outcomes.
	<i><b>Nonetheless, despite this acknowledgement, the actions of cargo cult followers are based upon 
	a “fallacious reasoning” of cause and effect. This could be summarized in the context of Java programming 
	as the assumption that if I, as a student, write my code like you, the lecturer, do, or use your 
	code as much as possible, I will be a programmer like you and this is what is required for me to 
	do well - or at least pass - this subject.</b></i> However, as teachers of Java it is necessary 
	to acknowledge the – perhaps dormant – presence of this attitude and to consequently offer offhand 
	code examples with extreme caution. I have repeatedly spotted examples of my own code embedded within 
	students’ projects. Although the code may originally have been offered as a quick and incomplete 
	example of a concept or a particular line of thinking it can too readily become the cornerstone 
	of larger scale classes without modification. It is perhaps, then unsurprising, that the cargo cult 
	attitude does, develop among students when they are first learning a programming language and the 
	concepts of programming. <i><b>The consequence of pursuing this belief unchecked parallels the effects 
	of learning in a “Java for Dummies” manner. Deeper, conceptual understanding and problem-solving 
	techniques remain undeveloped and students are left able only to imitate the step-by-step procedures 
	outlined by the textbook. </b></i>This step-by-step form of explicit instruction discourages exploration 
	and discourages students from appreciating the learning that is occurring when they disentangle 
	java compiler errors. This is perhaps one of the most revealing differences between students and 
	lecturers. <b><i>While experienced programmers use compiler errors, new programmers will see the 
	errors as “just one more thing” getting in the way of a successfully executing application. This 
	suggests a lack of awareness that programming is not synonymous with writing code.</i></b> The consuming 
	focus in the majority of undergraduate and postgraduate assessment projects is upon pursuing and 
	obtaining functionality in their code to the detriment of the user interface, clear documentation, 
	class structures, code reusability, extensibility or reliability.</font></p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2000_00_cargo_cults__in_java"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_beware_of_cargo_cult__coding" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2000_00_so_much_oo__so_little_reuse"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4><a target="_blank" href="http://www.eweek.com/article2/0,1759,1640340,00.asp">Beware of &#39;Cargo Cult&#39; 
Coding</a> <i>by Peter Coffee</i></h4>
<blockquote>
	<font size="2" face="Arial">When code is reused, and especially when code is acquired from outsourced 
	teams or incorporated via Web services technologies, there&#39;s a real opportunity for cargo cult practices 
	to take hold. Source code may follow unfamiliar naming conventions, and design documents and internal 
	memos may be written in unfamiliar languages or in a language that we know by people who don&#39;t speak 
	that language very well. We may not even have the source—we may have only WSDL (Web Services Description 
	Language) or some other interface definition to guide us.</font><p><font size="2" face="Arial">The 
	wooden headphones may bear fancy names like &quot;design patterns,&quot; but they&#39;re still an indicator that 
	we may be building systems that look like those that have worked before—instead of designing from 
	deep understanding toward solutions that meet new needs.</font></p>

	<p><font size="2" face="Arial">&quot;The first principle is that you must not fool yourself,&quot; said the 
	late physicist Richard Feynman in the 1974 Caltech commencement address that&#39;s often considered 
	the origin of the &quot;cargo cult&quot; phrase, at least as used by coders. That&#39;s a good principle. Reusing 
	code that we don&#39;t understand or reusing familiar methods merely because we do understand them are 
	behaviors for which we should be on guard. </font></p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2000_00_beware_of_cargo_cult__coding"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_so_much_oo__so_little_reuse" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2000_00_"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4><a target="_blank" href="http://www.ddj.com/articles/1998/9875/9875g/9875g.htm">&nbsp;So Much OO, 
So Little Reuse</a></h4>
<blockquote>

	<h6><a target="_blank" href="http://www.ddj.com/articles/1998/9875/9875g/9875g.htm">May 7, 1998</a></h6>

	<p><font size="2">In the not-so-recent past, headlines proclaimed, &quot;Software ICs Will Revolutionize 
	Computer Programming.&quot; ind development would reduce programming to assembling standardized &quot;objects,&quot; 
	and that the need for programmers would decline as software &quot;technicians&quot; with minimal training 
	would develop the software of the future.</font></p>

	<p><font size="2">Ten years have passed, and this clearly hasn&#39;t happened. Skilled programmers are 
	in greater demand, the skill levels required are higher, and software is harder to develop. The 
	business press says that nirvana is now just around the corner; companies that have the words &quot;object-oriented&quot; 
	in their business plan are in demand among venture firms. Yet object-oriented methodologies are 
	over 20 years old. Are today&#39;s technological forecasts any more accurate than those of 10 years 
	ago?</font></p>

	<p><font size="2">This is not to say that OO can&#39;t work. There are examples of successful OO projects; 
	usually these are showcase projects staffed with top developers. For the most part, however, object-oriented 
	technology has not been the &quot;magic bullet.&quot; In this article, I&#39;ll briefly discuss some reasons that 
	OO has thus far failed to deliver. More importantly, I&#39;ll address some ways that organizations with 
	average programmers can achieve high levels of reuse and shorten development cycles.</font></p>

	<h3><font size="2">Let me count the way</font></h3>

	<p><font size="2">The principal benefit cited for object-oriented methodologies is &quot;reuse.&quot; This 
	sounds like a valuable benefit; if we improve reuse, we write less code. Less code means faster 
	development and easier maintenance in the future. Less code also means fewer chances for bugs, so 
	it indirectly affects product quality. However, industry watchers report that there is only 15 percent 
	average reuse in today&#39;s object-based projects. That&#39;s a pretty damning statistic, if true; we did 
	better 20 years ago with COBOL subroutines! Others have cited different statistics; one major consulting 
	firm reports 25 percent reuse across clients, and some academic centers report 80 percent reuse. 
	So what&#39;s the real story?</font></p>

	<p><font size="2">All of these figures beg the question: &quot;How do you measure reuse?&quot; Is reuse a 
	measure of code that is referenced in more than one place? (Subroutines could do that before OO.) 
	Is code referenced in 50 places counted differently from code referenced in two places? One measure 
	of reuse might be the size of an application developed using OO technology versus one developed 
	using a different technology. This measurement, however, is impossible to perform, as such systems 
	don&#39;t exist. Further, a search of the literature turns up no widely-used standards for measuring 
	reuse.</font></p>

	<p><font size="2">Yet another complication is the granularity involved in measuring reuse. The usual 
	unit is the object itself. But no one looks inside the object. One can create a simple object that 
	can be used for only one specific function. This object can be made to serve more functions (thus 
	improving its reuse) by adding methods to it. Perhaps, however, the same programming benefit could 
	have been achieved by creating a new object for the additional functions rather than enhancing the 
	first object with additional methods. The amount of programming work is the same in both cases, 
	but the bulkier single object with additional methods counts for a higher level of reuse to most 
	people, even though this object is carrying around a lot of unused &quot;baggage&quot; in any one instantiation.</font></p>

	<p><font size="2">The bottom line is that there is no practical objective way to measure reuse. 
	Anyone out to make a point (positive or negative) about reuse can find a metric to prove that point. 
	This creates a new problem. If you can&#39;t measure something, how can you improve it? For the time 
	being, we will have to assume that we know good reuse when we see it, even if we can&#39;t measure it. 
	We can do this by observing how long it takes to develop an application or how much code it takes 
	to develop the application (assuming experienced, competent programmers). By using this subjective 
	approach, it is apparent to most developers that we are still losing ground.</font></p>

	<h3><font size="2">Objects and Components</font></h3>

	<p><font size="2">Agreeing on what constitutes an &quot;object&quot; is a fundamental problem with object-oriented 
	technology. In theory, an object represents a real-world entity, such as a person, vehicle, merchandise, 
	etc. Yet most programmers think of objects as processing entities -- listboxes, text widgets, windows, 
	etc. While it would be possible to start with widgets and, through encapsulation and inheritance, 
	end up with, say, vehicles, developers just don&#39;t do this when building real systems. So one problem 
	is that most OO development is not truly object oriented, but rather programming with predefined 
	widgets. Just because you are programming in C++ does not mean that you are doing object-oriented 
	development. As we used to say, &quot;Real FORTRAN programmers can write FORTRAN in any language&quot; -- 
	and real procedural programmers can write procedural code in C++.</font></p>

	<p><font size="2">There is a well-established, theoretical basis for object-oriented methodology. 
	Even if some developers don&#39;t understand it, don&#39;t use it correctly, or disagree with it, there 
	is a body of reference material that precisely defines objects and regulates their use.</font></p>

	<p><font size="2">The computer industry has recently begun to shift focus from &quot;objects&quot; to &quot;components&quot; 
	as the answer to our dreams. But what is a component? Some simply use the term &quot;component&quot; as another 
	name for a widget. I have a catalog in front of me that purports to offer &quot;components.&quot; It includes 
	charting tools, a cryptographic package, a Text Edit control developer&#39;s kit, a collection of widgets 
	(grids, trees, notebooks, meters, etc.), communications drivers, and similar entities. This definition 
	of &quot;component&quot; is not the answer we are seeking, however.</font></p>

	<p><font size="2">A search of the literature doesn&#39;t help, either. There are many articles that 
	discuss components, but few that actually define a component. Industry expert Judith Hurwitz says, 
	&quot;Components are made up of business rules, application functionality, data, or resources that are 
	encapsulated to allow reuse in multiple applications.&quot; Alan Radding, who writes about multi-tier 
	development, responds, &quot;In [Judith] Hurwitz Consulting&#39;s hypertier scheme, everything in effect 
	ends up as a component.&quot; Don Kiely, writing about components for IEEE&#39;s Computer magazine never 
	actually defines components, but he does define &quot;framework assemblies&quot; as groups of components &quot;that 
	could be plugged into an application as easily as individual components.&quot; This is a significant 
	statement because it shows that Kiely, Hurwitz, and Radding are thinking along the same lines, even 
	if they use different words. Kiely also makes the useful observation that, &quot;to be truly effective, 
	components should be portable and inter-operable across applications,&quot; something that I will come 
	back to later.</font></p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2000_00_so_much_oo__so_little_reuse"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2000_00_the_object_oriented__hype"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4>&nbsp;</h4>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2000_00_"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_the_object_oriented__hype" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2000_00_bad_engineering_properties_of_object_oriented_language"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4><a target="_blank" href="http://slashdot.org/articles/01/01/09/1420258.shtml">The Object Oriented 
Hype</a> </h4>

<h5>Discussion of&nbsp; B. Jacobs paper Object Oriented Programming Oversold!</h5>
<blockquote>

	<h6><a target="_blank" href="http://slashdot.org/articles/01/01/09/1420258.shtml">Slashdot </a>
	</h6>

	<p><b>jon_c</b>&nbsp; </p>
	<blockquote>

		<p><b><i>common misconception</i></b> </p>

		<p>one common misconception is that one can not do object oriented design in C, or any language 
		that isn&#39;t approved by the OOP zealots. this is just not true, while it may be more natural 
		to write a good object oriented design in C++, Java or Smalltalk. it can also be done in C or 
		BASIC. <br>
		<br>
		one can create objects in C by creating a structure, then passing that structure to every method 
		that performs on that structure. a common use could be something like this.</p>
		<blockquote>

			<p>struct window_t win; <br>
			window_init(&amp;win) <br>
			window_draw(&amp;win); <br>
			window_destroy(&amp;win); </p>
		</blockquote>

		<p>it is also possible to perform polymorphism and inheritance with function pointers and other 
		techniques. </p>
	</blockquote>

	<p><b>Omega</b>&nbsp; </p>
	<blockquote>

		<p>I tend to agree with the author..&nbsp; </p>

		<p>OOP (IMHO -- I&#39;m crazy for the acronyms today), is just a fad. Like structured programming 
		was before it.. Unfortunately a lot of these companies today fall into &quot;trendy&quot; programming 
		methodologies. Personally, I believe you should program using the style you&#39;re most comfortable 
		and familiar with. If you&#39;re trying to fit a mold it will slow you down..</p>
	</blockquote>

	<p><b>AlgUSF</b></p>
	<blockquote>

		<p>The biggest problem with OOP is when people use it too much, and end up with like a million 
		classes. </p>
	</blockquote>

	<p><br>
	Duh,the comparison is simple! (1)<br>
	<br>
	Hairy_Potter | about 13 years ago<br>
	× <br>
	<br>
	Both communism and OOP rely on the concept of classes for the fundamental flavor.</p>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2000_00_the_object_oriented__hype"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_bad_engineering_properties_of_object_oriented_language" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2000_00_oop_criticism"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4><a target="_blank" href="http://research.compaq.com/SRC/articles/199702/BadPropertiesOfOO.html">
Bad Engineering Properties of Object-Oriented Language</a></h4>
<blockquote>

	<p><font size="2">These problems form obstacles to the further development of object-oriented software 
	engineering, and in some situations are beginning to cause its outright rejection. Such problems 
	can be solved either by a variety of ad hoc tools and methodologies, or by progress in language 
	technology (both design and implementation). Here are some things that could or should be done in 
	the various areas.</font></p>
	<ul>

		<li><font size="2"><b>Economy of execution</b>. Much can be done to improve the efficiency of 
		method invocation by clever program analysis, as well as by language features (e.g. by &quot;final&quot; 
		methods and classes); this is the topic of a large and promising body of current work. We also 
		need to design type systems that can statically check many of the conditions that now require 
		dynamic subclass checks.</font> </li>

		<li><font size="2"><b>Economy of compilation</b>. We need to adopt languages and type systems 
		that allow the separate compilation of (sub)classes, without resorting to recompilation of superclasses 
		and without relying on &quot;private&quot; information in interfaces.</font> </li>

		<li><font size="2"><b>Economy of small-scale development</b>. Improvements in type systems for 
		object-oriented languages will improve error detection and the expressiveness of interfaces. 
		Much promising work has been done already and needs to be applied or further deployed
		<a href="#anchor232387">[1]</a> <a href="#anchor234657">[5]</a>.</font> </li>

		<li><font size="2"><b>Economy of large-scale development</b>. Major progress should be achieved 
		by formulating and enforcing inheritance interfaces: the contract between a class and its subclasses 
		(as opposed to the instantiation interface which is essentially an object type). This recommendation 
		requires the development of adequate language support. Parametric polymorphism is beginning 
		to appear in many object-oriented languages, and its interactions with object-oriented features 
		need to be better understood. Subtyping and subclassing must be separated. Similarly, classes 
		and interfaces must be separated.</font> </li>

		<li><font size="2"><b>Economy of language features</b>. Prototype-based languages have already 
		tried to reduce the complexity of class-based languages by providing simpler, more composable 
		features. Even within class-based languages, we now have a better understanding of how to achieve 
		simplicity and orthogonality, but much remains to be done. How can we design an object-oriented 
		language that is powerful and simple; one that allows powerful engineering but also simple and 
		reliable engineering?</font></li>
	</ul>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2000_00_bad_engineering_properties_of_object_oriented_language"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_oop_criticism" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#n2000_00_external_links"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4><a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/oopbad.htm">OOP Criticism</a> 
-- good&nbsp; OOP criticism and OOP problems (<i>The emperor has no clothes!). Contains a very good 
collection of links</i></h4>
<blockquote>

	<p>Contents </p>
	<ul>

		<li><a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/index.html">
		<font size="2">To Main</font></a></li>

		<li><a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/oop_qa.htm">
		<font size="2">OOP Questions &amp; Answers</font></a> </li>

		<li><a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/top.htm">
		<font size="2">Table Oriented Programming</font></a> </li>

		<li><font size="2">
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/meyer1.htm">Critique 
		of Bertrand Meyer&#39;s OOSC2</a> <b><i>NEW!</i></b></font> </li>

		<li><font size="2">
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/challeng.htm">Code 
		Challenge to OO Fans</a> <b><i>NEW!</i></b></font> </li>

		<li><font size="2">
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/guitable.htm">Tabled 
		GUI&#39;s</a> (alternative to OOP GUI&#39;s)</font> </li>

		<li><font size="2">
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/buzzword.htm">Buzz-Words</a> 
		(Incoherentance, Entrapsulation, Polydwarfism, and others)</font> </li>

		<li><a target="_blank" href="http://160.79.243.122/forum.htm"><font size="2">An OOP Forum</font></a>
		</li>

		<li><a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/paradgms.htm">
		<font size="2">Competing Paradigms</font></a> </li>

		<li><a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/goals.htm">
		<font size="2">OOP&#39;s Goals</font></a> </li>

		<li>
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/herrings.htm#quiet">
		<font size="2">Why More Don&#39;t Speak Up</font></a> </li>

		<li><a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/subtypes.htm">
		<font size="2">Subtype Proliferation Myth</font></a> </li>

		<li><font size="2">
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/driver.htm">The Driver 
		Pattern</a> A Narrow Niche?</font> </li>

		<li><font size="2">
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/miscoop.htm">OOP Criticism 
		Part 2</a> (includes <b>Black Box</b> issues)</font> </li>

		<li><font size="2">Code and scenario examples:
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/shapes.htm">Shapes</a>,
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/bank.htm">Bank</a>,
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/lib.htm">Publications</a></font></li>
	</ul>

	<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2000_00_oop_criticism"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_external_links" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#NEWS_TOC"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4><font size="2">External Links</font></h4>
	<ul>

		<li><font size="2"><a target="_blank" href="http://www.ddj.com/oped/1998/finc.htm">Reuse Not 
		High</a> according to Dr. Dobb&#39;s</font> </li>

		<li><font size="2">
		<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/reustalk.htm">Other 
		Comments on Reuse and OOP</a> (Wikiwiki forums)</font> </li>

		<li><font size="2">
		<a target="_blank" href="http://www.embedded.com/1999/9908/9908feat1.htm">Nuts to OOP</a> (The 
		&quot;emperor clothes&quot; reference was made independently)</font> </li>

		<li><a target="_blank" href="http://members.xoom.com/thomasn/n_man.htm"><font size="2">More 
		on &quot;Nuts to OOP&quot;</font></a> </li>

		<li><font size="2">
		<a target="_blank" href="http://www.usenix.org/publications/library/proceedings/sf94/johnson.html">
		Objecting To Objects, by Stephen C. Johnson</a> (full article requires a membership, but you 
		can still read the summary)</font> </li>

		<li><font size="2"><a target="_blank" href="http://members.aol.com/shaz7862/critique.htm">OOP 
		Paradigm Critique by Shajan Miah </a>(It is a long article and I have not fully reviewed it 
		yet.)</font> </li>

		<li>
		<a target="_blank" href="http://iraf.noao.edu/iraf/web/ADASS/adass_proc/adass_95/cogginsj/cogginsj.html">
		<font size="2">Critique of OOP by James M. Coggins</font></a> </li>

		<li><font size="2"><a target="_blank" href="http://www.informationweek.com/708/08iuhid.htm">
		Reuse Is Tough</a> (An InfoWeek article not really about OO, but a good reality check)</font></li>
	</ul>
</blockquote>

<center><table border="0" width="100"><tr>
<td align="center"><a href="#n2000_00_external_links"><img border="0" src="/Images/up.png" width="16" height="16"></a></td>
<td align="center"><a name="n2000_00_critique_of_the_object_oriented__paradigm_beyond_object_orientation" href="#NEWS_TOC"><img border="0" src="/Images/home.gif" width="16" height="18"></a></td>
<td align="center"><a href="#NEWS_TOC"><img border="0" src="/Images/down.png" width="16" height="16"></a></td>
</tr></table></center>
<h4><a target="_blank" href="http://members.aol.com/shaz7862/critique.htm">Critique of the Object Oriented 
Paradigm: Beyond Object-Orientation</a> <i><b>Date: 14th May, 1997</b></i>&nbsp; <i><b>Shajan Miah</b></i></h4>
<blockquote>

	<p><font size="2" face="Arial">This research study, investigates some of the problems and unresolved 
	issues in the OOPar. Contrary to adopting a WHAT (<i>the problem) </i>and HOW (<i>the solution)
	</i>approach it uniquely asks WHY these problem and issues exist. We argue that the WHAT &amp; HOW approach, 
	although useful in the short term, does not provide a long term solution to the problems in data 
	modelling (DM). As a result of adopting such an approach and the empirical and wide ranging nature 
	of chapter 3, four aspects are proposed. </font></p>
</blockquote>
<blockquote>

	<p><font face="Arial"><b><font size="2">2.0 Concepts of the OO model</font></b><font size="2">
	</font></font></p>

	<p><font size="2" face="Arial">The main concepts that underline the OOPar, are outlined in the following 
	sections. </font></p>

	<p><font face="Arial"><b><font size="2">2.1 Object Classes &amp; Objects</font></b><font size="2">
	</font></font></p>

	<p><font size="2" face="Arial">In the OOPar, the problem domain is modeled using object-classes, 
	and there instances objects (Booch, 1994). An object is any abstract or real world item that is 
	relevant to the system. An object class is a grouping of these objects. For example, in a library 
	information system an object-classes would be such things as members, books, etc. Objects would 
	be instances of these classes, e.g. Joe Bloggs, Object-oriented analysis by Martin, etc. </font>
	</p>

	<p><font face="Arial"><b><font size="2">2.2 Methods</font></b><font size="2"> </font></font></p>

	<p><font size="2" face="Arial">Methods are predefined operations, and are associated with an object-class. 
	&quot;Methods specify the way in which an object&#39;s data are manipulated&quot; (Martin &amp; Odell, (1992), p.17). 
	Therefore, the member object class identified earlier may contain methods such as reserve_book, 
	borrow_book, and etc. Access to an object is only granted via the methods. </font></p>

	<p><font size="2" face="Arial">This, in fact is one of the key features of the OO model, that is 
	behaviour (methods) and data-structures (i.e. the declarative aspect of an object) are not separated 
	- these are encapsulated together in one module. </font></p>

	<p><font face="Arial"><b><font size="2">2.3 Encapsulation</font></b><font size="2"> </font>
	</font></p>

	<p><font size="2" face="Arial">The process of keeping methods and data together, and granting access 
	to the object only through the methods is referred to as encapsulation. This achieves <i>information 
	hiding</i>, i.e. &quot;The object hides its data from other objects and allows the data to be accessed 
	via its own methods&quot; (Martin &amp; Odell, p.17). </font></p>

	<p><font face="Arial"><b><font size="2">2.4 Inheritance</font></b><font size="2"> </font></font>
	</p>

	<p><font size="2" face="Arial">Inheritance is the process, where a high-level object class can be 
	specialised into sub-classes. Wirfs-Brock et al(1990), define inheritance as &quot;... the ability of 
	one class to define the behaviour and data structure of its instances as a superset of the definition 
	of another class or classes.&quot; (p.24). </font></p>

	<p><font size="2" face="Arial">For example, in the library system, at a later stage we may find 
	that two types of members exist, children and adult. To accommodate this, we can make use of inheritance 
	by abstracting all the common features into a high-level member class and further create two new 
	sub-classes, adult-members and child-members, under the member class. Sub-classes would also inherit 
	data and functions from the super class. </font></p>

	<p><font face="Arial"><b><font size="2">2.4.1 Multiple Inheritance</font></b><font size="2">
	</font></font></p>

	<p><font size="2" face="Arial">Multiple inheritance, is almost identical in concepts to single inheritance, 
	however in this case a sub-class can inherit from many super-classes. For example, at a later design 
	stage of the library system, we may have a situation, where a book is of type fiction and is also 
	a reference book. This potentially, allows the use of multiple inheritance. </font></p>

	<p><font face="Arial"><b><font size="2">2.4 Polymorphism &amp; Dynamic Binding</font></b><font size="2">
	</font></font></p>

	<p><font size="2" face="Arial">The term polymorphism, originates from the Greek word &#39;poly morph&#39; 
	meaning many forms. In the context of the OOPar, the polymorphism concept allows different objects 
	to react to the same stimuli (i.e. message) differently (Hymes, 1995). For example, adult and child 
	members, may only be allowed to borrow books for up to 6 and 3 weeks respectively. Therefore the 
	borrow_book message to the adult-member class will respond differently (i.e. date books by 6 weeks), 
	than the same message to the child-member class (date books by 3 weeks). There are variations and 
	degrees of polymorphism (e.g. operator overloading), which the interested reader is guided to standard 
	OO textbooks (<i>see refs. at end</i>). </font></p>

	<p><font face="Arial"><b><font size="2">2.5 Genericity</font></b><font size="2"> </font></font>
	</p>

	<p><font size="2" face="Arial">Generic (or parametric) classes are those that define a whole family 
	of related classes, differing only in matters concerning one or more types that are used as arguments 
	to the class of declarations (deChampeux et al, 1993). The concept of genericity allows the designer 
	to specify standard generic classes that can be reused. For example, in designing any system, a 
	number of common programming situations require the same class structure to be applied to different 
	data types. Examples of several situations in user interface systems are the following: </font>
	</p>

	<p><font size="2" face="Arial">queue class </font></p>
	<ul>

		<li><font size="2" face="Arial">a queue of characters entered by a user </font></li>

		<li><font size="2" face="Arial">a queue of mouse events that have occurred and are waiting to 
		be handled. </font></li>
	</ul>

	<p><font size="2" face="Arial">In each case the same basic algorithms and supporting data structures 
	are needed. What varies among uses of the class is the type of the data being manipulated. Lists 
	are also used to maintain relationships in OO programming languages, hence in the case of the library 
	system a standard generic list class could be defined to maintain the relationship between members 
	and books reserved, for example. </font></p>

	<p><font face="Arial"><b><font size="2">3.0 Claimed Benefits</font></b><font size="2"> </font>
	</font></p>

	<p><font size="2" face="Arial">This section describes some of the key, general claimed benefits 
	of the OOPar. The list is, of course, not extensive and their are many other claimed benefits of 
	this approach which are described later, in their respective sections. </font></p>

	<p><font face="Arial"><b><font size="2">3.1 Naturalness of Analysis &amp; Design (Cognition)</font></b><font size="2">
	</font></font></p>

	<p><font size="2" face="Arial">One of the frequently claimed benefits of the OOPar is that it is 
	natural (therefore more understandable), and is assumed to be cognitively similar to the way human 
	beings perceive and understand the real-world (Meyer, (1988); Rosson &amp; Alpert (1988); Rosson &amp; Alpert(1990). 
	Martin &amp; Odell (1992, p.31) for example, states &quot;The way of thinking is more natural for most people 
	than the techniques of structured analysis and design. After all, the world consists of objects.&quot; 
	Mcfadden &amp; Hoffer(1994, p.) similarly note &quot;The notation and approach of the object-oriented data 
	model builds on these paradigms that people constantly use to cope with complexity.&quot; This claim, 
	therefore assumes that it is more natural for developers to decompose a problem into objects, at 
	least as compared to the traditional structured languages. In other words, it should be natural 
	for developers and users to map the problem into objects and into classification hierarchies.
	</font></p>

	<p><b><font size="2" face="Arial">3.2 Software Reuse </font></b></p>

	<p><font size="2" face="Arial">Software reuse is perhaps the most publicised benefits of the OOPar. 
	Advocates of the OOPar claim that it provides effective mechanisms to allow for software to be reused 
	(Meyer,1988). For example Budd(1996), states &quot;Well designed objects in object-oriented systems are 
	the basis for systems to be assembled largely from reusable modules, leading to higher productivity.&quot; 
	(p.31). Martin &amp; Odell(1992), similarly state &quot;It [OO] leads to world of reusable classes, where 
	much of the software construction process will be the assembly of existing well-proven classes.&quot; 
	(p.31). </font></p>

	<p><font size="2" face="Arial">These mechanisms are encapsulation, polymorphism, and inheritance. 
	For example, encapsulation allows object classes to be modified, or even added to new systems without 
	requiring additional modification to other classes in the system. The end-goal of this, is to develop 
	a component based software industry (as Martin &amp; Odell point out), where classes can be purchased, 
	and plugged in. Inheritance allows existing code to be reused. Genericity allows the reuse of one 
	standard class. </font></p>

	<p><font face="Arial"><b><font size="2">3.3 Communication Process</font></b><font size="2">
	</font></font></p>

	<p><font size="2" face="Arial">Curtis &amp; Waltz (1990) and Krasner, Curtis, &amp; Iscoe(1987), report 
	that at the software team level, some of the key problems encountered are communication and coordination, 
	capturing and using domain knowledge and organisational issues. With the OO approach, advocates 
	claim that communication and coordination between the project team and client(s), and also within 
	the team are enhanced. For example, Rumbaugh et al(1991, p.4), claimed that &quot;greatest benefits [of 
	OO] come from helping specifiers, developers, express abstract concepts and communicate them to 
	each other. Martin &amp; Odell (1992, p.34) also similarly state, &quot;Business people more easily understand 
	the OO paradigm. They think in terms of objects.....OO methodologies encourage better understanding 
	as the end users and developers share a common model.&quot; Similar statements can be found in many popular 
	text books, e.g. (Coad &amp; Yourdan (1991, p.3); Jacobson, Christerson, Johnsson, &amp; Overgaard, (1992, 
	p.43); Wirfs-Brock, Wilkerson, &amp; Weiner (1990, pp. 10 - 11). </font></p>

	<p><font size="2" face="Arial">This claim is based on two premises: </font></p>
	<ol>

		<li><font size="2" face="Arial">Naturalness of OO (described above) makes understanding easier,
		</font></li>

		<li><font size="2" face="Arial">Objects are constructed from the problem domain, hence communication 
		between project team and client(s) is enhanced. Also, because a single representation permeates 
		throughout all stages of life-cycle, therefore communication and coordination within the team 
		is facilitated. </font></li>
	</ol>

	<p><font face="Arial"><b><font size="2">3.4 Refinement &amp; Extensibility</font></b><font size="2">
	</font></font></p>

	<p><font size="2" face="Arial">OO advocates, also claim that &quot;software&quot; developed using the OOPar 
	is easy to refine and extend. </font></p>

	<p><font size="2" face="Arial">Khoshafian(1990) states &quot;Object oriented programming techniques allow 
	the development of extensible and reusable modules&quot; (p.274). Graham(1994), similarly notes, &quot;Inheritance, 
	genericity or other forms of polymorphism make exception handling easier and improve the extensibility 
	of systems.&quot; (p.37). These claims are related to three key principles of the OOPar, encapsulation, 
	inheritance and polymorphism. </font></p>

	<p><font size="2" face="Arial">For example, encapsulation allows the internal implementation of 
	a class to be modified without requiring changes to its services (i.e. methods). It also allows 
	new classes to be added to a system, without major modifications to the system. Inheritance allows 
	the class hierarchy to be further refined, and combined with polymorphism, the superclass does not 
	have to &quot;know&quot; about the new class, i.e. modifications do not have to be made at the superclass.
	</font></p>

	<p><font face="Arial"><b><font size="2">4.0 Definition of OO Model</font></b><font size="2">
	</font></font></p>

	<p><font size="2" face="Arial">In critiquing a concept it is common to start with a formal definition. 
	However, in this research project we will not do this, for the following reasons: </font></p>

	<p><font size="2" face="Arial">1. Unlike the relational model, the OO model does not have one commonly 
	accepted formal definition. </font></p>

	<p><font size="2" face="Arial">2. As a result of (1) trying to define the OO model, is in itself 
	a considerable research task. </font></p>

	<p><font size="2" face="Arial">Our approach will, therefore be to investigate reported problems 
	in the application of the OOPar, and academic critiques. And, then to try and identify common threads 
	and similarities between these problems. </font></p>

	<p><font face="Arial"><b><font size="2">5.0 Conclusion</font></b><font size="2"> </font></font>
	</p>

	<p><font size="2" face="Arial">In summary, in section 2 we outlined some of the core concepts that 
	underline the OO model. Section 3 provided an outline of some of the key claimed benefits of the 
	OO model. Finally in section 4, we discussed our reasons for not formally defining the OO model.
	</font></p>
</blockquote>

<p>&nbsp;</p>

<h2 align="center"><a name="See Also">See Also</a></h2>

<p><a href="../../Scripting/index.shtml">Scripting languages</a></p>
<ul>

	<li>

	<p><a href="../../Scripting/tcl.shtml">Tcl</a></p>
	</li>

	<li>

	<p><a href="../../Scripting/perl.shtml">Perl</a></p>
	</li>

	<li>

	<p><a href="../../Scripting/python.shtml">True Python</a></p>
	</li>
</ul>

<p><a href="../../Lang/index.shtml">Compiled languages</a></p>
<ul>

	<li>

	<p><a href="../../Lang/c.shtml">C</a></p>
	</li>

	<li>

	<p><a href="../../Lang/cpp.shtml">C++</a></p>
	</li>
</ul>
<hr>

<h2 align="center"><a name="Recommended_Links">Recommended Links</a></h2>
<table border="0" width="100%" height="110">
<tr>
<td width="100%" align="center">	

<h3><a href="/topvisited_history.shtml">Softpanorama Top Visited</a></h3>
<iframe src="/topvisited.shtml" width="100%" height="330"><p>Your browser does not support iframes.</p>
</iframe>
</td>
</table>
<h3>Softpanorama Recommended</h3>


<p><a  target="_blank" href="http://okmij.org/ftp/Computation/Subtyping/">Subtyping, Subclassing, and Trouble with
<abbr>OOP </abbr></a></p>

<p><abbr>UML </abbr>criticism by A.J.H.Simons and coauthors </p>
<ul>

	<li><a  target="_blank" href="http://www.dcs.shef.ac.uk/~ajhs/abstracts.html#uml37thg">37 Things That Don&#39;t Work 
	in Object Modelling with <abbr>UML </abbr></a></li>

	<li><a  target="_blank" href="http://www.dcs.shef.ac.uk/~ajhs/abstracts.html#uml30thg">30 Things That Go Wrong in 
	Object Modelling with <abbr>UML </abbr>1.3 </a></li>

	<li><a  target="_blank" href="http://www.dcs.shef.ac.uk/~ajhs/abstracts.html#harmful">Use Cases Considered Harmful
	</a></li>
</ul>

<p><a  target="_blank" href="http://www.paulgraham.com/">Paul Graham </a>and <a  target="_blank" href="http://mumble.net/~jar/">Jonathan 
Rees </a>discuss the nature and appeal of object-orientation. (Graham holds quite hackerish views regarding 
language design that want a bit the specific sense of esthetics that comes with mathematical culture, 
and his take on abstraction really is somewhat flat, but anyway ...) </p>
<ul>

	<li><a  target="_blank" href="http://www.paulgraham.com/reesoo.html">what&#39;s OO and whom does it attract? </a>
	</li>

	<li><a  target="_blank" href="http://www.paulgraham.com/noop.html">why OO isn&#39;t sexy </a></li>

	<li><a  target="_blank" href="http://www.eros-os.org/pipermail/e-lang/2001-October/005852.html">why OO is despicable
	</a></li>
</ul>

<p><a  target="_blank" href="http://www.reocities.com/tablizer/oopbad.htm">Object Oriented Programming Oversold! </a>
Detailed <abbr>OOP </abbr>criticism by a programmer of business applications who advocates a procedural/relational 
approach factoring out the management of relationships to the database. </p>

<p><a  target="_blank" href="http://www-pu.informatik.uni-tuebingen.de/users/sperber/java-sucks/">Why Java is not my 
favorite programming language </a></p>

<p><a  target="_blank" href="http://www.usenix.org/publications/library/proceedings/sf94/full_papers/johnson.html">Objecting 
to Objects, by Stephen C. Johnson</a> (USENIX conference invited talk, 1994)</p>

<p><a  target="_blank" href="http://harmful.cat-v.org/software/OO_programming/">Object Oriented Programming is Inherently 
Harmful</a></p>
<ul>

	<li>&quot;<em>Object-oriented programming is an exceptionally bad idea which could only have originated 
	in California.</em>&quot; -- Edsger Dijkstra</li>

	<li>&quot;<em>object-oriented design is the roman numerals of computing.</em>&quot; --
	<a  target="_blank" href="http://genius.cat-v.org/rob-pike/">Rob Pike</a></li>

	<li>&quot;<em>The phrase &quot;object-oriented&quot; means a lot of things. Half are obvious, and the other half 
	are mistakes.</em>&quot; -- Paul Graham</li>

	<li>&quot;<em>Implementation inheritance causes the same intertwining and brittleness that have been 
	observed when goto statements are overused. As a result, OO systems often suffer from complexity 
	and lack of reuse.</em>&quot; -- John Ousterhout <em>Scripting, IEEE Computer, March 1998</em></li>

	<li>&quot;<em>90% of the shit that is popular right now wants to rub its object-oriented nutsack all 
	over my code</em>&quot; -- kfx</li>
</ul>
</div>

<p>&nbsp;</p>

<p><a target="_blank" href="http://members.aol.com/shaz7862/critique.htm">Critique of the Object Oriented 
Paradigm: Beyond Object-Orientation</a> <i><b>Date: 14th May, 1997</b></i>&nbsp; <i><b>Shajan Miah</b></i></p>
<blockquote>

	<p><font size="2" face="Arial">This research study, investigates some of the problems and unresolved 
	issues in the OOPar. Contrary to adopting a WHAT (<i>the problem) </i>and HOW (<i>the solution)
	</i>approach it uniquely asks WHY these problem and issues exist. We argue that the WHAT &amp; HOW approach, 
	although useful in the short term, does not provide a long term solution to the problems in data 
	modelling (DM). As a result of adopting such an approach and the empirical and wide ranging nature 
	of chapter 3, four aspects are proposed. </font></p>
</blockquote>

<p><a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/oopbad.htm">OOP Criticism</a> 
-- good&nbsp; OOP criticism and OOP problems (<i>The emperor has no clothes!). Contains a very good 
collection of links</i></p>

<h4>External Links </h4>
<ul>

	<li><a target="_blank" href="http://www.ddj.com/documents/s=909/ddj9875g/9875g.htm">OOP Reuse Not 
	High</a> <small>according to Dr. Dobb&#39;s - 5/7/1998, by L. Finch</small> </li>

	<li><a target="_blank" href="http://www.embedded.com/story/OEG20011214S0098">The Failure of Reuse 
	(in embedded systems)</a><small> by Jack Ganssle</small> </li>

	<li><a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/reustalk.htm">Other 
	Comments on Reuse and OOP</a><small> (Wikiwiki forums)</small> </li>

	<li><a target="_blank" href="http://www.embedded.com/1999/9908/9908feat1.htm">Nuts to OOP</a><small> 
	(The &quot;emperor clothes&quot; reference was made independently) </small></li>

	<li><a target="_blank" href="http://members.xoom.com/thomasn/n_man.htm">More on &quot;Nuts to OOP&quot;</a>
	</li>

	<li>
	<a target="_blank" href="http://www.usenix.org/publications/library/proceedings/sf94/johnson.html">
	Objecting To Objects, by Stephen C. Johnson</a> <small>(A C++ perspective)</small> </li>

	<li><a target="_blank" href="http://members.aol.com/shaz7862/critique.htm">OOP Paradigm Critique 
	by Shajan Miah </a><small>(It is a long article and I have not fully reviewed it yet.)</small>
	</li>

	<li>
	<a target="_blank" href="http://iraf.noao.edu/iraf/web/ADASS/adass_proc/adass_95/cogginsj/cogginsj.html">
	Critique of OOP by James M. Coggins</a> </li>

	<li><a target="_blank" href="http://www.informationweek.com/708/08iuhid.htm">Reuse Is Tough</a>
	<small>(An InfoWeek article not really about OO, but a good reality check)</small> </li>

	<li><a target="_blank" href="http://www.sdmagazine.com/documents/s=732/sdm0104n/0104n.htm">No Silver 
	Bullets</a> <small>by Warren Keuffel</small> </li>

	<li><a target="_blank" href="http://www.bluetail.com/~joe/vol1/v1_oo.html">BlueTail&#39;s &quot;Why OO Sucks&quot;</a> 
	- <small>Quote: <i>If a [paradigm] is so bad that it creates a new industry to solve problems of 
	its own making, then it must be a good idea for the guys who want to make money. </i></small>
	</li>

	<li><a target="_blank" href="http://www.paulgraham.com/noop.html">Paul Graham Excluding OOP From 
	New Language</a> <font size="3">- Paul co-started a very successful e-stores company using LISP.
	</font><font size="2">To my chagrin, however, he does not like databases either. LISP shares my 
	philosophy of treating larger-scale data organization similar to code organization. I just think 
	that nested lists are less &quot;grokkable&quot; and flexible than (good) tables.</font> </li>

	<li><a target="_blank" href="http://www.dbdebunk.com">Database Debunkings</a> <small>- A website 
	influenced by the ideas of Chris Date, the author of a popular university database textbook. Date 
	generally finds object orientation conceptually impure compared to relational theory, and believes 
	that OO thinking re-exposes
	<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/core1.htm">outdated database</a> 
	and data structure thinking of the 1960&#39;s (specifically hierarchical and network databases).</small>
	</li>

	<li><a target="_blank" href="http://dreamsongs.com/ObjectsHaveFailedNarrative.html">Objects Have 
	Failed</a> <small>- Narrative by Richard P. Gabriel. Some of it seems to be complaining about lack 
	of dynamic languages more than about OO itself. I wonder if Richard would not be complaining if 
	SmallTalk was &quot;in&quot; instead of Java. </small></li>

	<li><a target="_blank" href="http://www.devx.com/opinion/Article/26776">OOP Better in Theory than 
	in Fact</a> <small>- R. Mansfield&#39;s complaints about OO that seem to echo many of the complaints 
	presented here. (Coincidence? I&#39;ll let you be the judge.) Note that I generally do not support
	<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/reustalk.htm#copyandpaste">
	copy-and-paste</a> for reuse. There are plenty of other non-OO ways to get reuse. </small></li>

	<li><a target="_blank" href="http://www.tonymarston.net/php-mysql/oop-for-heretics.html">OOP for 
	Heretics</a><small> - Tony Marston has similarly found out the world of OOP lacks consistency and
	<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/science.htm">science</a>.
	</small></li>

	<li><a target="_blank" href="http://lambda-the-ultimate.org/node/view/893">&quot;We Don&#39;t Need No Stinkin&#39; 
	OO Proof!&quot;</a><small> - Well at least some are realizing there is no real evidence. &quot;Feels good&quot; 
	is sufficient for this guy. I would like to see his allegedly inferior procedural code. He was probably 
	just bad at procedural. Many OO fans are. See
	<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/model.htm">here</a> as 
	far as the modeling claim. </small></li>
</ul>
<hr>

<h2 align="center"><a name="Recommended Papers">Recommended Papers</a></h2>

<h4><a  target="_blank" href="http://www.usenix.org/publications/library/proceedings/sf94/full_papers/johnson.html">USENIX 
- Invited Talk Objecting to Objects</a></h4>
<blockquote>

	<p>Object Oriented Programming (OOP) is currently being hyped as the best way to do everything from 
	promoting code reuse to forming lasting relationships with persons of your preferred sexual orientation. 
	This paper tries to demystify the benefits of OOP. We point out that, as with so many previous software 
	engineering fads, the biggest gains in using OOP result from applying principles that are older 
	than, and largely independent of, OOP. Moreover, many of the claimed benefits are either not true 
	or true only by chance, while occasioning some high costs that are rarely discussed. Most seriously, 
	all the hype is preventing progress in tackling problems that are both more important and harder: 
	control of parallel and distributed applications, GUI design and implementation, fault tolerant 
	and real-time programming. OOP has little to offer these areas. Fundamentally, you get good software 
	by thinking about it, designing it well, implementing it carefully, and testing it intelligently, 
	not by mindlessly using an expensive mechanical process. </p>
</blockquote>

<h4><a target="_blank" href="http://www.sdmagazine.com/features/fr_3.htm">Software Development Online
</a>Four-Wheel Drive, Garbage Barges and Objects.&nbsp; </h4>
<blockquote>

	<h6>June&nbsp; 2000.</h6>

	<p><a target="_blank" href="http://www.sdmagazine.com/tocs/2000/06tc.shtml">Table of Contents</a></p>

	<p><font size="2">
	<!-- ENTER DECK HERE -->Object-oriented design is supposed to make our software more robust and 
	resilient, yet we still see systems that are as fragile as their procedural ancestors. Are developers 
	adopting aggressive practices because they think the technology will protect them?</font></p>
	<!-- ENTER AUTHOR NAME HERE; EDIT LINK DESTINATION-->

	<p><font size="2">by
	<a target="_blank" href="http://www.sdmagazine.com/sdonline/authors.html#sadolph">Steve Adolph</a></font></p>

	<p><font size="2">Object-oriented software development practices are supposed to make our software 
	more robust and resilient to change. Yet we still see systems designed using these practices that 
	are as rigid and fragile as their procedural ancestors. Adding new features still causes a cascade 
	of change throughout the software and often results in the creation of new bugs. It wasn’t supposed 
	to be this way. Many software development organizations invested heavily in object technology, expecting 
	something better. They expected the changes to be localized and the software to be resilient to 
	bugs. Is it possible that object technology is the software equivalent of four-wheel drive? Does 
	it provide greater control and safety, only to be abused by programmers who develop more aggressively 
	because they think objects will protect them?</font></p>

	<p><font size="2">The problem is, today’s object-oriented software often lacks modularity. The systems 
	are just as hard, if not harder, than their procedural brethren to modify or enhance. What appear 
	to be simple one-line fixes end up taking three weeks to implement. Simple alterations cause a cascade 
	of sympathetic changes to wash over the entire system.</font></p>

	<p><font size="2">It is my argument that we rely too heavily on object technology’s safety features 
	and ignore good software development practices such as planning, design, review and assessment in 
	the name of expediency. We hope that at least one of our four driving wheels will somehow grab and 
	prevent us from losing control on the slippery roadway we have been driving along at a reckless 
	speed.</font></p>
</blockquote>

<p><a target="_blank" href="http://www.progsoc.uts.edu.au/~geldridg/chackrm.html">Re Beware of C Hackers 
-- A rebuttal to Bertrand Meyer by Robert Martin (3 Jul 95)</a> Meyer makes a clear difference between 
C programmers and C hackers. He even states that he expects everyone to know C (at least back in &#39;95, 
when they had that discussion), he knows C himself very well and he points to the fact that some C hackers 
are not well-suited for the creation of huge, complex systems that must be reliable because they (=the 
hackers) chase for runtime and memory efficiency and lose sight of the more important points maintainability, 
readability etc. I think he has a point there. He does not use the term &#39;C hacker&#39; for someone who is 
a good programmer and uses C, as you might assume.</p>
<blockquote>

	<p><font size="2">I have recently acquired a copy of Bertrand Meyer&#39;s new book &quot;Object Success&quot;. 
	I would like to say that I have a great deal of respect for Meyer. Moreover, I have read many good 
	things in this book so far.</font> </p>

	<p><font size="2">However I take extreme exception to something he wrote in this book. On page 91 
	he writes the following which is included in its entirety. I will comment on it afterwards.</font>
	</p>
	<hr>
	<blockquote>

		<p><font size="2">PRUDENT HIRING PRINCIPLE: Beware of C hackers.</font> </p>

		<p><font size="2">A &quot;C hacker&quot; is somewone who has had too much practice writing low-level C 
		software and making use of all the special techniques and tricks permitted by that language.</font>
		</p>

		<p><font size="2">Why single out C? First, interestingly enough, one seldom hears about Pascal 
		hackers, Ada hackers or Modula hackers. C, which since the late nineteen-seventies has spread 
		rapidly throughought the computing community, especially in the USA, typifies a theology of 
		computing where the Computer is the central deity and its altar reads Efficiency. Everything 
		is sacrificed to low-level performance, and programs are built in terms of addresses, words, 
		memory cells, pointers, manual memory allocation and deallocation, unsafe type conversions, 
		signals and similar machine-oriented constructs. In this almost monotheist cult, where the Microsecond 
		and the Kilobyte complete the trinity, there is little room for such idols of software engineering 
		as Readability, Provability and Extendibility.</font> </p>

		<p><font size="2">Not surprisingly, former believers need a serious debriefing before they can 
		rejoin the rest of the computing community and its progress towards more modern forms of software 
		development.</font> </p>

		<p><font size="2">The above principle does not say &quot;Stay away from C hackers&quot;, which would show 
		lack of faith in the human aptitude to betterment. There have indeed been cases of former C 
		hackers who became born-again O-O developers. But in general you should be cautious about including 
		C hackers in your projects, as they are often the ones who have the most trouble adapting to 
		the abstraction-based form of software development that object technology embodies.</font>
		</p>
	</blockquote>
	<hr>

	<p><font size="2">There is only one word that can accurately describe these sentiments. That word 
	is biggotry. I don&#39;t like to use a word like that to describe the words of someone who is obviously 
	intelligent. Yet there is no other option. The words he has written create a class of people whom 
	he recommends ought to be hired, only with caution.</font> </p>

	<p><font size="2">Who are these &quot;C Hackers&quot;? Has Dr. Meyer given us any means to identify them? 
	Yes.</font> </p>
	<blockquote>
		<font size="2"><br>
		A &quot;C hacker&quot; is somewone who has had too much practice writing low-level C software and making 
		use of all the special techniques and tricks permitted by that language.</font>
	</blockquote>

	<p><font size="2">What possible recourse can a manager have but to look with prejudice against anyone 
	who happens to put &quot;C&quot; on their resume. By associating &quot;C&quot; with &quot;Hackers&quot;, Dr. Meyer damages everyone 
	who uses that language, whether they are hackers are not. In effect, Dr. Meyer is making a statement 
	that is equivalent to: &quot;Beware of the Thieving Frenchmen.&quot;</font> </p>

	<p><font size="2">What is a hacker? A hacker is someone who writes computer programs without employing 
	sound principles of software engineering. Someone who simply throws code together without thought 
	to structure or lifecycle.</font> </p>

	<p><font size="2">Certainly there are hackers who use C. But there are Hackers who use every language. 
	And in this, Dr. Meyer is quite negligent, for he says nearly the opposite:<br>
	</font></p>
	<blockquote>
		<font size="2">Why single out C? First, interestingly enough, one seldom hears about Pascal 
		hackers, Ada hackers or Modula hackers.</font>
	</blockquote>

	<p><font size="2">This may or may not be true, I have no statistics. However, *if* it is true I 
	would be willing to bet that the reason has something to do with the difference in the number of 
	C programmers as compared to Ada, Pascal and Modula programmers. If there are 20 times as many C 
	programmers, then there are probably 20 times as many C hackers.</font> </p>

	<p><font size="2">My point is that C does not predispose someone to be a hacker. And that the ratio 
	of C hackers to C programmers is probably the same as Ada hackers to Ada programmers.</font> </p>

	<p><font size="2">So Dr. Meyer casts aspersions upon all C programmers while giving amnesty to Ada, 
	Pascal and Modula programmers. According to Dr. Meyer, it is only, or especially, the &quot;C hacker&quot; 
	that you must be wary of. He does not say: &quot;Beware of Hackers&quot;, rather he says: &quot;Beware of C hackers.&quot; 
	And this is simply biggotry, the segregation and defamation of a class of people based only upon 
	the language that the program in.</font> </p>

	<p><font size="2">And why this malevolence towards C? One can only conjecture. He offers reasons, 
	but they are nearly mystical in their descriptions. Consider:<br>
	</font></p>
	<blockquote>
		<font size="2">C [...] typifies a theology of computing where the Computer is the central deity 
		and its altar reads Efficiency.</font>
	</blockquote>

	<p><font size="2">Dr. Meyer does not provide any proof, or even a scrap of evidence to support this 
	rediculous claim. He states it as fact. This is an abuse of authority. What every author fears, 
	(or ought to fear in my opinion) is that he cast his own opinions as unalterable truth. Yet, rather 
	than proceed with trepdiation, Dr. Meyer seems to glory in his deprication of C. His writing becomes 
	almost frenzied as he attacks it.<br>
	</font></p>
	<blockquote>
		<font size="2">Everything is sacrificed to low-level performance, and programs are built in 
		terms of addresses, words, memory cells, pointers, manual memory allocation and deallocation, 
		unsafe type conversions, signals and similar machine-oriented constructs. In this almost monotheist 
		cult, where the Microsecond and the Kilobyte complete the trinity, there is little room for 
		such idols of software engineering as Readability, Provability and Extendibility.</font>
	</blockquote>

	<p><font size="2">Here he names every evil trick and bad practice that he can, and ascribes it all 
	to C, as though no other language had the capability of supporting bad practices. He also claims 
	that C programmers religiously follow these bad practices as the sacrements of their religion.</font>
	</p>

	<p><font size="2">These statements are extremely irresponsible. There is no basis of fact that Dr. 
	Meyer has supplied for these extreme accusations and defamations. Dr. Meyer has a right to dislike 
	C if he chooses. But his vehemence against its programmers is unreasonable, and unreasoned.</font>
	</p>

	<p><font size="2">It is easy to refute nearly all of Dr. Meyer&#39;s claims regarding C programmers. 
	I have known many many C programmers who were very concerned with good software engineering. Who 
	considered the quest for ulimate efficiency to be absurd. Who were careful with their programming 
	practices. In fact, I have never met a single C programmer who fits the description that Dr. Meyer 
	ascribes to them all.</font> </p>

	<p><font size="2">In my opinion, he is very wrong, not only professionally, but moraly. And he owes 
	the industry an apology and a retraction.</font> </p>
</blockquote>

<h4><a target="_blank" href="http://www.reocities.com/tablizer/meyer1.htm">Critique of OOSC2 by Bertrand 
Meyer</a></h4>
<blockquote>

	<h2><font size="2">Introduction</font></h2>
	<font size="2">I have been doing custom <b>business</b> programming for small and medium projects 
	since the late 1980&#39;s. When Object Oriented Programming started popping it&#39;s head into the mainstream, 
	I began looking into it to see how it could improve the type of applications that I work on.</font>
	<blockquote>
		<font size="2">Note that this excludes large business frameworks such as SAP, PeopleSoft, etc. 
		I have never built a SAP-clone and probably never will, as with many others in my niche.</font>
	</blockquote>
	<font size="2">I have come to the conclusion that although OO may help in building the fundamental 
	components of business applications, and even the language itself, any minor organizational improvement 
	OO adds to the applications themselves are not justified by the complexity, confusion, and training 
	effort it will likely add to a business-oriented language. In other-words, OO is <b>not a general-purpose</b> 
	software organizational paradigm, and &quot;selling&quot; it as such harms progress in the alternatives.</font>

	<p><font size="2">I have used languages where the GUI, collections handling, and other basic frameworks 
	are built into the language in such a way that OO&#39;s benefits would rarely help the language deal 
	with them. It is also my opinion that the language of base framework implementations probably should 
	not be the same as the application&#39;s language for the most part. For example, most Visual Basic 
	components are written in C++. Meyer seems to have more of a one-size-fits-all view of languages 
	and paradigms than I do.</font> </p>

	<p><font size="2">For a <b>preview</b> of my opinions and analysis of this situation, may I suggest 
	the following links:</font> </p>
	<font size="2">
	<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/oopbad.htm">Introduction 
	to OO criticism</a><br>
	<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/driver.htm">The Driver 
	Pattern</a><br>
	<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/subtypes.htm">Subtype Proliferation 
	Myth</a><br>
	<a target="_blank" href="http://www.geocities.com/SiliconValley/Lab/6888/miscoop.htm#blackbox">Black 
	Box Wire Bloat</a><br>
&nbsp;</font>

	<p><font size="2">Although the stated niche is not representative of all programming tasks, it is 
	still a rather large one and should not be ignored when choosing paradigms.</font> </p>

	<p><font size="2">Here is a quick summary of my criticisms of OOSC2:</font> </p>
	<ol>

		<li><font size="2">Meyer tends to build up false or crippled representations of OO&#39;s competitors, 
		which distorts OO&#39;s alleged comparative advantages.</font> </li>

		<li><font size="2">A good many of the patterns that OO improves are not something needed directly 
		by the stated niche, except in rare cases.</font> </li>

		<li><font size="2">We have very conflicting views and philosophies on data sharing.</font></li>
	</ol>

	<p><font size="2">Note that although my writing style has at times been called sarcastic and harsh, 
	please do not confuse the delivery tone with the message.</font> </p>

	<p><font size="2">Also note that I am <b>not</b> against abstraction and generic-ness. I am only 
	saying that OO&#39;s brand of these is insufficient for my niche.</font> </p>
</blockquote>

<h4><a target="_blank" href="http://members.aol.com/shaz7862/critique.htm">Critique of the Object Oriented 
Paradigm: Beyond Object-Orientation.</a> By Shajan Miah Date: 14th May, 1997</h4>

<p>C++ Critique</p>
<ul>
	<font size="2">

	<li><b><a target="_blank" href="http://www.elj.com/elj/v1/n3/mpj/">The basic pitfalls of adopting 
	object orientation</a></b> by <a href="mailto:76334.1247@compuserve.com">Meilir Page-Jones</a></li>

	<li><a target="_blank" href="http://members.aol.com/shaz7862/critique.htm"><b>Critique of the Object 
	Oriented Paradigm: Beyond Object-Orientation</b></a> by
	<a target="_blank" href="http://members.aol.com/shaz7862/">Shajan Miah</a></li>

	<li><b><a href="ftp://ftp.cwi.nl/pub/CWIreports/AP/CS-R9457.ps.Z">A trying C++ experience (Why COMPARE 
	dropped C++)</a></b> in The Journal of C Language Translation, Vol.6, No.2, Dec 1994 (Postscript)</li>
	</font></li>

	<li>

	<p><a target="_blank" href="http://www.elj.com/cppcv3/">Table of Contents - C++ A Critique of C++ 
	.. (3rd Ed. Ian Joyner Oct 1996)</a>&nbsp; -- a pretty weak critique of C++ from the position of 
	OO diehard</p>
	</li>
</ul>

<hr>

<h2 align="center"><a name="OO Hype">OO Hype</a></h2>

<p>For a more or less reasonable sample of OO advocacy one can read
<a target="_blank" href="http://www.waysys.com/ws_content_al_ibe.html">Object Orientation: The Importance 
of Being Earnest</a></p>
<hr>
<hr noshade color="#FF0000" size="5"><center>
<script type="text/javascript"><!--
google_ad_client = "ca-pub-4031247137266443";
/* upper */
google_ad_slot = "4815841291";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</center>
<hr noshade color="#FF0000" size="5">

<h2><a name="Etc">Etc</a></h2>

<p>FAIR USE NOTICE This site contains 
		copyrighted material the use of which has not always been specifically 
		authorized by the copyright owner. We are making such material available 
		in our efforts to advance understanding of environmental, political, 
		human rights, economic, democracy, scientific, and social justice 
		issues, etc. We believe this constitutes a 'fair use' of any such 
		copyrighted material as provided for in section 107 of the US Copyright 
		Law. In accordance with Title 17 U.S.C. Section 107, the material on 
		this site is distributed without profit exclusivly for research and educational purposes.&nbsp;&nbsp; If you wish to use 
		copyrighted material from this site for purposes of your own that go 
		beyond 'fair use', you must obtain permission from the copyright owner.&nbsp; </p>

<p>ABUSE: IPs or network segments from which we detect a stream of probes might be blocked for no 
less then 90 days. Multiple types of probes increase this period.&nbsp;&nbsp; </p>

<p><b>Society</b></p>
<blockquote>

<p><b><a href="/Skeptics/groupthink.shtml"><font size="2">Groupthink</font></a><font size="2"> :
<a href="/Skeptics/Political_skeptic/Two_party_system_as_poliarchy/index.shtml">Two Party System 
as Polyarchy</a> : 
<a href="/Skeptics/Financial_skeptic/Casino_capitalism/Corruption_of_regulators/index.shtml">
Corruption of Regulators</a> :
<a href="/Social/Bureaucracy/index.shtml">Bureaucracies</a> :
<a href="/Social/Toxic_managers/Micromanagers/understanding_micromanagers.shtml">Understanding Micromanagers 
and Control Freaks</a> : <a href="/Social/Toxic_managers/index.shtml">Toxic Managers</a> :&nbsp;&nbsp;
<a href="/Skeptics/Pseudoscience/harvard_mafia.shtml">Harvard Mafia</a> :
<a href="/Social/Toxic_managers/Communication/diplomatic_communication.shtml">Diplomatic Communication</a> 
: <a href="/Social/Toxic_managers/surviving_a_bad_performance_review.shtml">Surviving a Bad Performance 
Review</a> : <a href="/Skeptics/Financial_skeptic/index.shtml">Insufficient Retirement Funds as 
Immanent Problem of Neoliberal Regime</a> : <a href="/Skeptics/index.shtml">PseudoScience</a> :
<a href="/Skeptics/Political_skeptic/index.shtml">Who Rules America</a> :
<a href="/Skeptics/Political_skeptic/Neoliberalism/index.shtml">Neoliberalism
</a>&nbsp;: <a href="/Skeptics/Political_skeptic/Elite_theory/iron_law_of_oligarchy.shtml">The Iron 
Law of Oligarchy</a> : </font><a href="/Skeptics/Political_skeptic/libertarianism.shtml">
<font size="2">Libertarian Philosophy</font></a></b></p>
</blockquote>

<p><b>Quotes</b></p>
<blockquote>

<p><b><font size="2" face="Arial"> 
<a href="/Skeptics/Quotes/war_and_peace_quotes.shtml">War and Peace</a> </font>
<font face="Arial"><font size="2">: <a href="/Skeptics/Quotes/financial_quotes.shtml">Skeptical 
Finance</a></font><font size="2"> : <a href="/Skeptics/Quotes/famous_galbraith_quotes.shtml">John 
Kenneth Galbraith</a> :<a href="/Skeptics/Quotes/talleyrand_quotes.shtml">Talleyrand</a> :
<a href="/Skeptics/Quotes/oscar_wilde_quotes.shtml">Oscar Wilde</a> :
<a href="/Skeptics/Quotes/bismarck_quotes.shtml">Otto Von Bismarck</a> :
<a href="/Skeptics/Quotes/keynes_quotes.shtml">Keynes</a> :
<a href="/Skeptics/Quotes/george_carlin.shtml">George Carlin</a> :
<a href="/Skeptics/skeptical_quotes.shtml">Skeptics</a> :
<a href="/Skeptics/Quotes/propaganda.shtml">Propaganda</a>&nbsp; : <a href="/SE/quotes.shtml">SE 
quotes</a> : <a href="/Lang/quotes.shtml">Language Design and Programming Quotes</a> :
<a href="/Bulletin/quotes.shtml">Random IT-related quotes</a> :&nbsp;
<a href="/Skeptics/Quotes/somerset_maugham.shtml">Somerset Maugham</a> :
<a href="/Skeptics/Quotes/marcus_aurelius.shtml">Marcus Aurelius</a> :
<a href="/Skeptics/Quotes/kurt_vonnegut_quotes.shtml">Kurt Vonnegut</a> :
<a href="/Skeptics/Quotes/eric_hoffer.shtml">Eric Hoffer</a> :
<a href="/Skeptics/Quotes/churchill_quotes.shtml">Winston Churchill</a> :
<a href="/Skeptics/Quotes/napoleon_quotes.shtml">Napoleon Bonaparte</a> :
<a href="/Skeptics/Quotes/ambrose_bierce.shtml">Ambrose Bierce</a> :&nbsp;
<a href="/Skeptics/Quotes/bernard_shaw.shtml">Bernard Shaw</a> : </font>
<a href="/Skeptics/Quotes/mark_twain_quotes.shtml"><font size="2">Mark Twain Quotes</font></a></font></b></p>
</blockquote>

<p><b>Bulletin:</b></p>
<blockquote>

<p><b><font face="Arial"><a href="http://softpanorama.biz/Bulletin/Sp2013_v25/bulletin25_12.shtml">
<font size="2">Vol 25, No.12 (December, 2013) Rational Fools vs. Efficient Crooks The efficient 
markets hypothesis</font></a><font size="2"> :
<a href="http://softpanorama.biz/Skeptics/Political_skeptic/Bulletin/political_skeptic2013.shtml">
Political Skeptic Bulletin, 2013</a> :
<a href="http://softpanorama.biz/Skeptics/Financial_skeptic/Unemployment/Bulletin/unempoyment2010.shtml">
Unemployment Bulletin, 2010</a> :
<a href="http://softpanorama.biz/Bulletin/Sp2011_v23/bulletin23_10.shtml">&nbsp;Vol 23, No.10 
(October, 2011) An observation about corporate security departments</a> :
<a href="http://softpanorama.biz/Skeptics/Political_skeptic/Fifth_column/Color_revolutions/Euromaydan/Bulletin/euromaydan14_06.shtml">
Slightly Skeptical Euromaydan Chronicles, June 2014</a> :
<a href="http://softpanorama.biz/Skeptics/Financial_skeptic/Casino_capitalism/12_Apostols_of_deregulation/Greenspan/Bulletin/greenspan_bulletin2008.shtml">
Greenspan legacy bulletin, 2008</a> :
<a href="/Bulletin/Sp2013_v25/bulletin25_10.shtml">Vol 25, No.10 (October, 2013) Cryptolocker Trojan 
(Win32/Crilock.A)</a> :
<a href="/Bulletin/Sp2013_v25/bulletin25_08.shtml">Vol 25, No.08 (August, 2013) Cloud providers 
as intelligence collection hubs</a> : 
<a href="http://softpanorama.biz/Skeptics/Financial_skeptic/Humor/Bulletin/financial_humor2010.shtml">
Financial Humor Bulletin, 2010</a> :
<a href="http://softpanorama.biz/Skeptics/Financial_skeptic/Inequality/Bulletin/inequality2009.shtml">
Inequality Bulletin, 2009</a> :
<a href="http://softpanorama.biz/Skeptics/Financial_skeptic/Humor/Bulletin/financial_humor2008.shtml">
Financial Humor Bulletin, 2008</a> :
<a href="http://softpanorama.biz/Copyright/Bulletin/copyleft_problems2004.shtml">Copyleft Problems 
Bulletin, 2004</a> :
<a href="http://softpanorama.biz/Skeptics/Financial_skeptic/Humor/Bulletin/financial_humor2011.shtml">
Financial Humor Bulletin, 2011</a> :
<a href="http://softpanorama.biz/Skeptics/Financial_skeptic/Energy/Bulletin/energy_bulletin2010.shtml">
Energy Bulletin, 2010</a> : <a href="http://softpanorama.biz/Malware/Bulletin/malware2010.shtml">
Malware Protection Bulletin, 2010</a> : <a href="/Bulletin/Sp2014_v26/bulletin26_01.shtml">Vol 26, 
No.1 (January, 2013) Object-Oriented Cult</a> :
<a href="http://softpanorama.biz/Skeptics/Political_skeptic/Bulletin/political_skeptic2011.shtml">
Political Skeptic Bulletin, 2011</a> :
<a href="/Bulletin/Sp2011_v23/bulletin23_11.shtml">Vol 23, No.11 (November, 2011) Softpanorama classification 
of sysadmin horror stories</a> : <a href="/Bulletin/Sp2013_v25/bulletin25_05.shtml">Vol 25, No.05 
(May, 2013) Corporate bullshit as a communication method</a>&nbsp; : </font><a href="/Bulletin/Sp2013_v25/bulletin25_06.shtml">
<font size="2">Vol 25, No.06 (June, 2013) A Note on the Relationship of Brooks Law and Conway Law</font></a></font></b></p>
</blockquote>

<p align="left"><b>History:</b></p>
<blockquote>

<p><b><font face="Arial"><a href="/History/index.shtml"><font size="2">Fifty glorious years (1950-2000): 
the triumph of the US computer engineering</font></a><font size="2"> :
<a href="/People/Knuth/index.shtml">Donald Knuth</a> : <a href="/People/Knuth/taocp.shtml">TAoCP 
and its Influence of Computer Science</a> : <a href="/People/Stallman/index.shtml">Richard Stallman</a> 
: <a href="/People/Torvalds/index.shtml">Linus Torvalds</a>&nbsp; :
<a href="/People/Wall/index.shtml">Larry Wall </a>&nbsp;:
<a href="/People/Ousterhout/index.shtml">John K. Ousterhout</a> : <a href="/History/ctss.shtml">
CTSS</a> : <a href="/History/multix.shtml">Multix OS</a> <a href="/History/Unix/index.shtml">Unix 
History</a> : <a href="/People/Shell_giants/introduction.shtml">Unix shell history</a> :
<a href="/Editors/Vimorama/history.shtml">VI editor</a> :
<a href="/Scripting/Piporama/history.shtml">History of pipes concept</a> :
<a href="/Solaris/solaris_history.shtml">Solaris</a> : <a href="/History/dos_history.shtml">MS DOS</a> 
:&nbsp; <a href="/History/lang_history.shtml">Programming Languages History</a> :
<a href="/Lang/pl1.shtml">PL/1</a> : <a href="/Lang/simula67.shtml">Simula 67</a> :
<a href="/Lang/Cilorama/history.shtml">C</a> :
<a href="/People/Stallman/history_of_gcc_development.shtml">History of GCC development</a> :&nbsp;
<a href="/People/Scripting_giants/scripting_languages_as_vhll.shtml">Scripting Languages</a> :
<a href="/Scripting/Perlbook/Ch01/perl_history.shtml">Perl history&nbsp; </a>&nbsp;:
<a href="/History/os_history.shtml">OS History</a> : <a href="/Mail/history.shtml">Mail</a> :
<a href="/DNS/history.shtml">DNS</a> : <a href="/Net/Application_layer/SSH/ssh_history.shtml">SSH</a> 
: <a href="/History/cpu_history.shtml">CPU Instruction Sets</a> :
<a href="/Hardware/Sun/history_of_sparc.shtml">SPARC systems 1987-2006</a> :
<a href="/OFM/Paradigm/Ch03/norton_commander.shtml">Norton Commander</a> :
<a href="/Windows/Norton_utilities/history.shtml">Norton Utilities</a> :
<a href="/Windows/Ghosting/ghost_history.shtml">Norton Ghost</a> :
<a href="/Office/Frontpage/history.shtml">Frontpage history</a> :
<a href="/Malware/Malware_defense_history/index.shtml">Malware Defense History</a> :
<a href="/Utilities/Screen/history.shtml">GNU Screen</a> : </font>
<a href="/OSS/oss_early_history.shtml"><font size="2">OSS early history</font></a></font></b></p>
</blockquote>

<p><b>Classic books:</b></p>
<blockquote>

<p><b><font face="Arial"><a href="/Bookshelf/Classic/peter_principle.shtml"><font size="2">The Peter 
Principle</font></a><font size="2"> : <a href="/Bookshelf/Classic/parkinson_law.shtml">Parkinson 
Law</a> : <a href="/Bookshelf/Classic/nineteen_eighty_four.shtml">1984</a> :
<a href="/Bookshelf/Classic/tmmm.shtml">The Mythical Man-Month</a> :&nbsp;
<a href="/Bookshelf/Classic/polya_htsi.shtml">How to Solve It by George Polya</a> :
<a href="/Bookshelf/Classic/taocp.shtml">The Art of Computer Programming</a> :
<a href="/Bookshelf/Classic/teops.shtml">The Elements of Programming Style</a> :
<a href="/Bookshelf/Classic/unix_haters_handhook.shtml">The Unix Hater’s Handbook</a> :
<a href="/Bookshelf/Classic/jargon_file.shtml">The Jargon file</a> :
<a href="/Bookshelf/Classic/true_believer.shtml">The True Believer</a> :
<a href="/Bookshelf/Classic/programming_pearls.shtml">Programming Pearls</a> :
<a href="/Bookshelf/Classic/good_soldier_svejk.shtml">The Good Soldier Svejk</a> : </font>
<a href="/Bookshelf/Classic/power_elite.shtml"><font size="2">The Power Elite</font></a></font></b></p>
</blockquote>

<p><b>Most popular humor pages:</b></p>
<blockquote>

<p><font face="Arial"><b><a href="/Bulletin/Humor/Slackerism/it_slacker_manifest.shtml">
<font size="2">Manifest of the Softpanorama IT Slacker Society</font></a><font size="2"> :
<a href="/Bulletin/Humor/Slackerism/ten_commandments_of_software_slackerism.shtml">Ten Commandments 
of the IT Slackers Society</a> : <a href="/Bulletin/Humor/index.shtml">Computer Humor Collection</a> 
: <a href="/Bulletin/Humor/bsd_logo_story.shtml">BSD Logo Story</a> :
<a href="/Bulletin/Humor/cuckoo_egg.shtml">The Cuckoo&#39;s Egg </a>:
<a href="/Bulletin/Humor/slang.shtml">IT Slang</a> : <a href="/Lang/Cpp_rama/humor.shtml">C++ Humor</a> 
: <a href="/Bulletin/Humor/Archive/humor059.shtml">ARE YOU A BBS ADDICT?</a> :
<a href="/Bulletin/Humor/Archive/humor092.shtml">The Perl Purity Test</a> :
<a href="/Bulletin/Humor/Archive/humor065.shtml">Object oriented programmers of all nations</a> 
: <a href="/Skeptics/Financial_skeptic/Humor/financial_humor.shtml">Financial Humor</a> :
<a href="/Skeptics/Financial_skeptic/Humor/Bulletin/financial_humor2008.shtml">Financial Humor Bulletin, 
2008</a> : <a href="/Skeptics/Financial_skeptic/Humor/Bulletin/financial_humor2010.shtml">Financial 
Humor Bulletin, 2010</a> : <a href="/Editors/humor.shtml">The Most Comprehensive Collection of Editor-related 
Humor</a> : <a href="/Lang/programming_languages_humor.shtml">Programming Language Humor</a> :
<a href="/Skeptics/Financial_skeptic/Casino_capitalism/Systemic_instability_of_financial_sector/TBTF/Goldman_Sachs/humor.shtml">
Goldman Sachs related humor</a> :
<a href="/Skeptics/Financial_skeptic/Casino_capitalism/Twelve_apostles_of_deregulation/Greenspan/greenspan_humor.shtml">
Greenspan humor</a> : <a href="/Lang/Cilorama/humor.shtml">C Humor</a> :
<a href="/Scripting/humor.shtml">Scripting Humor</a> :
<a href="/Bulletin/Humor/real_programmers_humor.shtml">Real Programmers Humor</a> :
<a href="/WWW/humor.shtml">Web Humor</a> : <a href="/Copyright/humor.shtml">GPL-related Humor</a> 
: <a href="/OFM/ofm_humor.shtml">OFM Humor</a> :
<a href="/Skeptics/Political_skeptic/humor.shtml">Politically Incorrect Humor</a> :
<a href="/Security/IDS/humor.shtml">IDS Humor</a> : <a href="/Bulletin/Humor/linux_sucks.shtml">
&quot;Linux Sucks&quot; Humor </a>: <a href="/Links/Russian/Culture/Music/russian_musical_humor.shtml">Russian 
Musical Humor</a> : <a href="/Bulletin/Humor/best_russian_programmer_humor.shtml">Best Russian Programmer 
Humor</a> : <a href="/Bulletin/Humor/Archive/humor070.shtml">Microsoft plans to buy Catholic Church</a> 
: <a href="/People/Stallman/rms_related_humor.shtml">Richard Stallman Related Humor</a> :
<a href="/Admin/humor.shtml">Admin Humor</a> : <a href="/People/Wall/perl_related_humor.shtml">Perl-related 
Humor</a> : <a href="/People/Torvalds/linus_torvalds_related_humor.shtml">Linus Torvalds Related 
humor</a> : <a href="/Skeptics/humor.shtml">PseudoScience Related Humor</a> :
<a href="/Net/net_humor.shtml">Networking Humor</a> :
<a href="/Scripting/Shellorama/humor.shtml">Shell Humor</a> :
<a href="/Skeptics/Financial_skeptic/Humor/Bulletin/financial_humor2011.shtml">Financial Humor Bulletin, 
2011</a> : <a href="/Skeptics/Financial_skeptic/Humor/Bulletin/financial_humor2012.shtml">Financial 
Humor Bulletin, 2012</a> :
<a href="/Skeptics/Financial_skeptic/Humor/Bulletin/financial_humor2013.shtml">Financial Humor Bulletin, 
2013</a> : <a href="/Lang/Javarama/humor.shtml">Java Humor</a> : <a href="/SE/humor.shtml">Software 
Engineering Humor</a> : <a href="/Solaris/humor.shtml">Sun Solaris Related Humor</a> :
<a href="/Education/humor.shtml">Education Humor</a> : <a href="/Admin/Tivoli/ibm_humor.shtml">IBM 
Humor</a> : <a href="/Lang/Asmorama/humor.shtml">Assembler-related Humor</a> :
<a href="/Editors/Vimorama/vim_humor.shtml">VIM Humor</a> : <a href="/Malware/humor.shtml">Computer 
Viruses Humor</a> : <a href="/Bulletin/Humor/Archive/humor034.shtml">Bright tomorrow is rescheduled 
to a day after tomorrow</a> : <a href="/Bulletin/Humor/classic_computer_humor.shtml">Classic Computer 
Humor</a> </font></b></font></p>
</blockquote>

<p align="left"><b><a href="/Bulletin/Humor/last_but_not_least.shtml">The Last but not Least</a></b></p>
<hr size="5" noshade color="#FF0000"><font face="Verdana" size="1">

<p><i><b>Copyright © 1996-2015 by Dr. Nikolai Bezroukov</b></i>. <a target="_blank" href>www.softpanorama.org</a> 
was created as a service to the UN Sustainable Development Networking Programme (<a target="_blank" href="http://www.un.org/Depts/dhl/sflib/">SDNP</a>) 
in the author free time. This document is an industrial compilation designed and <b>created exclusively 
for educational use</b> and is distributed under the <a href="/license.shtml">Softpanorama Content License</a>. 
</p>

<p>The site uses AdSense so you need to be aware of Google privacy policy. You you do not want to be 
tracked by Google please disable Javascript for this site. <em>This site is perfectly usable without 
Javascript.</em> </p>

<p>Original materials copyright belong 
to respective owners. <i><b>Quotes are made<font color="#FF0000"> for educational purposes only</font> 
in compliance with the fair use doctrine. </b></i></p>

<p><em>FAIR USE NOTICE </em>This site contains 
		copyrighted material the use of which has not always been specifically 
		authorized by the copyright owner. We are making such material available 
		to advance understanding of computer science, IT technology, economic, scientific, and social  
		issues. We believe this constitutes a 'fair use' of any such 
		copyrighted material as provided by section 107 of the US Copyright Law according to which 
such material can be distributed without profit exclusively for research and educational purposes.</p>

<p><b>This is a Spartan WHYFF (We Help You For Free) 
site written by people for whom English is not a native language.</b> Grammar and spelling errors should 
be expected. <b>The site contain some broken links as it develops like a living tree...</b></p>

<table border="0" width="100%">
<tr>
<td><font face="Verdana" size="1">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
<img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</font></td>
<td><font face="Verdana" size="1">You can use PayPal to make a contribution, supporting development 
of this site and speed up access. In case softpanorama.org is down currently there are 
two functional mirrors: softpanorama.info (the fastest) and softpanorama.net.</font></td>
</tr>
</table>

<p><b>Disclaimer:</b> </p>

<p><i>The statements, views and opinions presented on this web page are those of the author (or 
referenced source) and are 
not endorsed by, nor do they necessarily reflect, the opinions of the author present and former employers, SDNP or any other organization the author may be associated with.</i> <i>We do not warrant the correctness 
of the information provided or its fitness for any purpose.</i></p>
</font>

<p>Last modified: <!--webbot bot="Timestamp" s-type="EDITED" s-format="%B %d, %Y" startspan -->February 19, 2014<!--webbot bot="Timestamp" i-checksum="41554" endspan --></p>

</body>

</html>
