<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg">
  <head>
<script type="text/javascript">window.NREUM||(NREUM={});NREUM.info={"beacon":"bam.nr-data.net","errorBeacon":"bam.nr-data.net","licenseKey":"61e2f91637","applicationID":"6852097","transactionName":"dAxbFxYNWlpXRBxXDUINXkwXCllB","queueTime":0,"applicationTime":504,"agent":""}</script>
<script type="text/javascript">window.NREUM||(NREUM={}),__nr_require=function(e,t,n){function r(n){if(!t[n]){var o=t[n]={exports:{}};e[n][0].call(o.exports,function(t){var o=e[n][1][t];return r(o||t)},o,o.exports)}return t[n].exports}if("function"==typeof __nr_require)return __nr_require;for(var o=0;o<n.length;o++)r(n[o]);return r}({1:[function(e,t,n){function r(e,t){return function(){o(e,[(new Date).getTime()].concat(a(arguments)),null,t)}}var o=e("handle"),i=e(2),a=e(3);"undefined"==typeof window.newrelic&&(newrelic=NREUM);var u=["setPageViewName","setCustomAttribute","finished","addToTrace","inlineHit"],c=["addPageAction"],f="api-";i(u,function(e,t){newrelic[t]=r(f+t,"api")}),i(c,function(e,t){newrelic[t]=r(f+t)}),t.exports=newrelic,newrelic.noticeError=function(e){"string"==typeof e&&(e=new Error(e)),o("err",[e,(new Date).getTime()])}},{}],2:[function(e,t,n){function r(e,t){var n=[],r="",i=0;for(r in e)o.call(e,r)&&(n[i]=t(r,e[r]),i+=1);return n}var o=Object.prototype.hasOwnProperty;t.exports=r},{}],3:[function(e,t,n){function r(e,t,n){t||(t=0),"undefined"==typeof n&&(n=e?e.length:0);for(var r=-1,o=n-t||0,i=Array(0>o?0:o);++r<o;)i[r]=e[t+r];return i}t.exports=r},{}],ee:[function(e,t,n){function r(){}function o(e){function t(e){return e&&e instanceof r?e:e?u(e,a,i):i()}function n(n,r,o){e&&e(n,r,o);for(var i=t(o),a=l(n),u=a.length,c=0;u>c;c++)a[c].apply(i,r);var s=f[g[n]];return s&&s.push([m,n,r,i]),i}function p(e,t){w[e]=l(e).concat(t)}function l(e){return w[e]||[]}function d(e){return s[e]=s[e]||o(n)}function v(e,t){c(e,function(e,n){t=t||"feature",g[n]=t,t in f||(f[t]=[])})}var w={},g={},m={on:p,emit:n,get:d,listeners:l,context:t,buffer:v};return m}function i(){return new r}var a="nr@context",u=e("gos"),c=e(2),f={},s={},p=t.exports=o();p.backlog=f},{}],gos:[function(e,t,n){function r(e,t,n){if(o.call(e,t))return e[t];var r=n();if(Object.defineProperty&&Object.keys)try{return Object.defineProperty(e,t,{value:r,writable:!0,enumerable:!1}),r}catch(i){}return e[t]=r,r}var o=Object.prototype.hasOwnProperty;t.exports=r},{}],handle:[function(e,t,n){function r(e,t,n,r){o.buffer([e],r),o.emit(e,t,n)}var o=e("ee").get("handle");t.exports=r,r.ee=o},{}],id:[function(e,t,n){function r(e){var t=typeof e;return!e||"object"!==t&&"function"!==t?-1:e===window?0:a(e,i,function(){return o++})}var o=1,i="nr@id",a=e("gos");t.exports=r},{}],loader:[function(e,t,n){function r(){if(!w++){var e=v.info=NREUM.info,t=s.getElementsByTagName("script")[0];if(e&&e.licenseKey&&e.applicationID&&t){c(l,function(t,n){e[t]||(e[t]=n)});var n="https"===p.split(":")[0]||e.sslForHttp;v.proto=n?"https://":"http://",u("mark",["onload",a()],null,"api");var r=s.createElement("script");r.src=v.proto+e.agent,t.parentNode.insertBefore(r,t)}}}function o(){"complete"===s.readyState&&i()}function i(){u("mark",["domContent",a()],null,"api")}function a(){return(new Date).getTime()}var u=e("handle"),c=e(2),f=window,s=f.document;NREUM.o={ST:setTimeout,CT:clearTimeout,XHR:f.XMLHttpRequest,REQ:f.Request,EV:f.Event,PR:f.Promise,MO:f.MutationObserver},e(1);var p=""+location,l={beacon:"bam.nr-data.net",errorBeacon:"bam.nr-data.net",agent:"js-agent.newrelic.com/nr-943.min.js"},d=window.XMLHttpRequest&&XMLHttpRequest.prototype&&XMLHttpRequest.prototype.addEventListener&&!/CriOS/.test(navigator.userAgent),v=t.exports={offset:a(),origin:p,features:{},xhrWrappable:d};s.addEventListener?(s.addEventListener("DOMContentLoaded",i,!1),f.addEventListener("load",r,!1)):(s.attachEvent("onreadystatechange",o),f.attachEvent("onload",r)),u("mark",["firstbyte",a()],null,"api");var w=0},{}]},{},["loader"]);</script>
    <title>Chapter 7. Advanced Virtual Machines</title>
    
    <meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/>
    
    
    
  <meta name="content-css" content="core.css"/><meta name="chunkId" value="61"/><link rel="prev" href="./60.xhtml"/><link rel="next" href="./62.xhtml"/><meta name="publisher" value="O'Reilly Media, Inc."/><meta name="media title" value="Automating Microsoft Azure Infrastructure Services"/><meta name="practice area" value="Programming/Developer"/><meta name="data-origPath" value="/html/body/section[@class='chapter' and @id='adv_vms']"/><meta name="chunkCount" value="71"/><link name="start" value="0.xhtml"/><link name="contents" value="toc.xhtml"/><script>window.OReader || (window.OReader = {});OReader.ownership = null;OReader.owned_content = [];</script><script src="/assets/chunk_manifest-c4eff8fc4c2bfa25fa6359d0d599e4c0.js"></script><link href="/assets/application-f3419368b2131789f969583abdd0ed8e.css" media="screen" rel="stylesheet" /><meta content="width=device-width, maximum-scale=1.0, minimum-scale=1.0, initial-scale=1.0" name="viewport"></head>
  <body><reader data-oreilly-reader-iframe opf={{opf}}
              display={{displayChunk}}
              on-loaderror=handleError(error)><div id=oreilly-readspeaker>
             
    <div class="sect1" title="Domain Join">
  <div class="titlepage">
    <div>
      <div>
        <h2 class="title" style="clear: both" id="_domain_join">Domain Join</h2>
      </div>
    </div>
  </div>
  <p><a id="id394085" class="indexterm"/><a id="id394093" class="indexterm"/>Using the Microsoft Azure PowerShell cmdlets, you can automatically domain-join a Windows-based virtual machine at provision time. Domain join works by passing domain-join information directly to the unattended install parameters for Windows setup at provision time.</p>
  <p>To specify the domain-join information, use the <code class="literal">Add-AzureProvisioningConfig</code> cmdlet with the <code class="literal">-WindowsDomain</code> parameter. Several properties are required to successfully join a virtual machine to the domain. You will need domain credentials that have rights in Active Directory to join the new computer to the domain, the domain name itself (NetBIOS and fully qualified), and optionally, you may specify an organizational unit (OU) in which to create the new computer account.</p>
  <div class="note" title="Active directory prerequisite">
    <h3 class="title">Active directory prerequisite</h3>
    <p><a id="id394121" class="indexterm"/>I am not going into detail on how to deploy Active Directory in Microsoft Azure. There is <a class="ulink" href="http://bit.ly/install_Active_Directory" target="_top">a great tutorial on the Microsoft Azure website</a> that covers this in full detail.</p>
  </div>
  <p><a class="xref" href="61.xhtml#EX-7-8" title="Example 7-7. Using the -WindowsDomain parameter for domain join">Example 7-7</a> is a partial example that shows how you could use the <code class="literal">-WindowsDomain</code> parameter to specify domain-join information for an existing Active Directory deployment. Assuming that the virtual network is configured to reference an Active Directory DNS server when the virtual machine is provisioned, it will automatically join the domain.</p>
  <div class="example">
    <a id="EX-7-8"/>
    <div class="example-title">Example 7-7. Using the -WindowsDomain parameter for domain join</div>
    <div class="example-contents">
      <pre class="programlisting"><code class="c"># Domain join information</code>
<code class="nv">$domain</code> <code class="p">=</code> <code class="s2">"contoso"</code>
<code class="nv">$domFQDN</code> <code class="p">=</code> <code class="s2">"contoso.com"</code>
<code class="nv">$domUser</code> <code class="p">=</code> <code class="s2">"[domain admin user]"</code>
<code class="nv">$domPass</code> <code class="p">=</code> <code class="s2">"[domain password]"</code>
<code class="c"># Adding the virtual machine to an organizational unit is optional</code>
<code class="c"># The OU must already exist</code>
<code class="nv">$domOU</code> <code class="p">=</code> <code class="s1">'OU=AzureVMs,DC=contoso,DC=com'</code>
<code class="c"># End domain join information</code>

<code class="nv">$serviceName</code> <code class="p">=</code> <code class="s2">"[cloud service name]"</code>
<code class="nv">$vmName</code> <code class="p">=</code> <code class="s2">"[vm name]"</code>
<code class="nv">$VNET</code> <code class="p">=</code> <code class="s2">"[virtual network name]"</code>
<code class="nv">$Subnet</code> <code class="p">=</code> <code class="s2">"[subnet name]"</code>
<code class="nv">$Location</code> <code class="p">=</code> <code class="s2">"[region name]"</code>

<code class="nv">$imageFamily</code> <code class="p">=</code> <code class="s2">"Windows Server 2012 R2 Datacenter"</code>
<code class="nv">$imageName</code> <code class="p">=</code> <code class="nb">Get-AzureVMImage</code> <code class="p">|</code>
                 <code class="n">where</code> <code class="p">{</code> <code class="nv">$_</code><code class="p">.</code><code class="n">ImageFamily</code> <code class="o">-eq</code> <code class="nv">$imageFamily</code> <code class="p">}</code> <code class="p">|</code>
                 <code class="n">sort</code> <code class="n">PublishedDate</code> <code class="n">-Descending</code> <code class="p">|</code>
                 <code class="n">select</code> <code class="n">-ExpandProperty</code> <code class="n">ImageName</code> <code class="n">-First</code> <code class="n">1</code>

<code class="nv">$vmConfig</code> <code class="p">=</code> <code class="nb">New-AzureVMConfig</code> <code class="n">-Name</code> <code class="nv">$vmName</code> <code class="n">-InstanceSize</code> <code class="n">Small</code> <code class="p">`</code>
                              <code class="n">-ImageName</code> <code class="nv">$imageName</code>

<code class="nv">$vmConfig</code> <code class="p">|</code> <code class="nb">Add-AzureProvisioningConfig</code> <code class="n">-WindowsDomain</code> <code class="p">`</code>
                                        <code class="n">-AdminUsername</code> <code class="nv">$adminUser</code> <code class="p">`</code>
                                        <code class="n">-Password</code> <code class="nv">$password</code> <code class="p">`</code>
                                        <code class="n">-Domain</code> <code class="nv">$domain</code> <code class="p">`</code>
                                        <code class="n">-JoinDomain</code> <code class="nv">$domFQDN</code> <code class="p">`</code>
                                        <code class="n">-DomainUserName</code> <code class="nv">$domUser</code> <code class="p">`</code>
                                        <code class="n">-DomainPassword</code> <code class="nv">$domPass</code> <code class="p">`</code>
                                        <code class="n">-MachineObjectOU</code> <code class="nv">$domOU</code>

<code class="nv">$vmConfig</code> <code class="p">|</code> <code class="nb">Set-AzureSubnet</code> <code class="n">-SubnetNames</code> <code class="nv">$Subnet</code>

<code class="nv">$vmConfig</code> <code class="p">|</code> <code class="nb">New-AzureVM</code> <code class="n">-ServiceName</code> <code class="nv">$serviceName</code> <code class="p">`</code>
                        <code class="n">-Location</code> <code class="nv">$location</code> <code class="n">-VNetName</code> <code class="nv">$VNET</code></pre>
    </div>
  </div>
</div>
    <div class="sect1" title="Using PowerShell Remoting">
  <div class="titlepage">
    <div>
      <div>
        <h2 class="title" style="clear: both" id="_using_powershell_remoting">Using PowerShell Remoting</h2>
      </div>
    </div>
  </div>
  <p><a id="ix_ch07-asciidoc5" class="indexterm"/><a id="id394859" class="indexterm"/><a id="id394222" class="indexterm"/>PowerShell commands can be executed remotely on Windows-based virtual machines. Access can be enabled for connectivity over the Internet by using HTTPS, or virtual machine to virtual machine by using HTTP and internal IP addresses. External access (HTTPS) is enabled by default, and internal access is limited to the default configuration of Windows (which is limited to virtual machines on the same subnet) unless otherwise specified. For external (HTTPS) access, Microsoft Azure will automatically generate a self-signed certificate that you can use to secure your connection to the virtual machine over the Internet. You can specify your own certificate at provisioning time with the <code class="literal">-WinRMCertificate</code> if you want to use your own.</p>
  <p>You can change the default behavior by specifying the <code class="literal">-EnableWinRMHttp</code> parameter at provisioning time to extend the internal WinRM configuration to allow remote commands to work across subnets. You can also pass the  <code class="literal">-NoWinRMEndpoint</code> or <code class="literal">-DisableWinRMHttps</code> parameters to change the default external capabilities for PowerShell.</p>
  <div class="warning" title="Enabling PowerShell remoting is a provision-time feature" epub:type="warning">
    <h3 class="title">Enabling PowerShell remoting is a provision-time feature</h3>
    <p><a id="id394915" class="indexterm"/>Specifying <code class="literal">-DisableWinRMHttps</code> will tell the provisioning engine to not create the self-signed (or your own) certificate and to not configure WinRM on the virtual machine as part of the provisioning process. There is currently no cmdlet to enable this functionality after the virtual machine has been provisioned.</p>
  </div>
  <div class="sect2" title="Configuring a Secure Connection">
    <div class="titlepage">
      <div>
        <div>
          <h3 class="title" id="_configuring_a_secure_connection">Configuring a Secure Connection</h3>
        </div>
      </div>
    </div>
    <p><a id="ix_ch07-asciidoc6" class="indexterm"/><a id="ix_ch07-asciidoc7" class="indexterm"/>The first step to secure a PowerShell session is either to deploy your own certificate or to allow Microsoft Azure to generate a self-signed certificate for you.</p>
    <p>Deploying your own certificate is as easy as passing an <code class="literal">X509Certificate</code> to the <code class="literal">-WinRMCertificate</code> parameter of <code class="literal">Add-AzureProvisioningConfig</code> or <code class="literal">New-AzureQuickVM</code>. If you want to use the automatically generated certificate, there are a few prerequisites.</p>
    <p>To use the self-signed certificate generated by Microsoft Azure securely, you need to download that certificate and install it into your local certificate store. The code to do this is fairly complex, so a helper script has been created that can be downloaded from the<a id="id395008" class="indexterm"/> <a class="ulink" href="http://bit.ly/secure_remote_PowerShell_access" target="_top">TechNet Script Center</a>.</p>
    <div class="note" title="Elevation required">
      <h3 class="title">Elevation required</h3>
      <p>The TechNet script requires PowerShell to run elevated because it installs the self-signed certificate into the certificate store of your local machine.</p>
    </div>
    <p>To try this on your own, download the script from the TechNet Script Center gallery into a local directory (I used <span class="emphasis"><em>C:\Scripts</em></span>). When it is downloaded, use the <code class="literal">Unblock-File</code> cmdlet to unblock it (<code class="literal">Unblock-File "C:\Scripts\InstallWinRMCertAzureVM.ps1"</code>). Next, create a new elevated PowerShell session. You can launch PowerShell ISE or just <span class="emphasis"><em>PowerShell.exe</em></span> for this example. Finally, to simplify paths from within PowerShell, change the directory to the download folder: <code class="literal">CD C:\Scripts</code>.</p>
    <p>You will need to specify an existing virtual machine and cloud service that have been deployed using an image (see <a class="xref" href="61.xhtml#EX-7-9" title="Example 7-8. Using the sample script to enable secure access (Console pane)">Example 7-8</a> and <a class="xref" href="61.xhtml#a7.5" title="Figure 7-5. Installing the Microsoft Azure-generated certificate">Figure 7-5</a>). I am using one of the virtual machines that was created as part of <a class="xref" href="11.xhtml" title="Chapter 3. Virtual Machines">Chapter 3</a>.</p>
    <div class="example">
      <a id="EX-7-9"/>
      <div class="example-title">Example 7-8. Using the sample script to enable secure access (Console pane)</div>
      <div class="example-contents">
        <pre class="programlisting"><code class="nv">$subscription</code> <code class="p">=</code> <code class="s2">"[subscription name]"</code>
<code class="nv">$serviceName</code>  <code class="p">=</code> <code class="s2">"[cloud service name]"</code>
<code class="nv">$vmName</code> <code class="p">=</code> <code class="s2">"ps-vm1"</code>

<code class="p">.\</code><code class="n">InstallWinRMCertAzureVM</code><code class="p">.</code><code class="n">ps1</code> <code class="n">-SubscriptionName</code> <code class="nv">$subscription</code> <code class="p">`</code>
                <code class="n">-ServiceName</code> <code class="nv">$serviceName</code> <code class="n">-Name</code> <code class="nv">$vmName</code></pre>
      </div>
    </div>
    <div class="figure">
      <a id="a7.5"/>
      <div class="figure-contents">
        <div class="mediaobject">
          <img src="images-amas_0705.png" alt="Installing the Microsoft Azure-generated certificate"/>
        </div>
      </div>
      <div class="figure-title">Figure 7-5. Installing the Microsoft Azure-generated certificate</div>
    </div>
    <p>When the script has completed, the certificate is downloaded and installed to your client machine’s certificate store. You can now securely connect to the virtual machine in Microsoft Azure by using PowerShell.</p>
    <p>You will need to specify the connection URI and credentials to connect to the virtual machine. <code class="literal">Get-AzureWinRMUri</code> is a helper cmdlet that queries all of the network endpoints for the specified virtual machine and returns the URI with the public port for the WinRM endpoint. The URI can then be passed to the remote PowerShell cmdlets to open or create a new session or to invoke a script block.</p>
    <p><a class="xref" href="61.xhtml#EX-7-10" title="Example 7-9. Entering a remote PowerShell session (Console pane)">Example 7-9</a> uses the <code class="literal">Get-AzureWinRMUri</code> cmdlet to return the remote PowerShell URI and store it in the <code class="literal">$uri</code> variable. <code class="literal">Get-Credential</code> is then called to prompt for login credentials for the virtual machine, which are then stored in the <code class="literal">$cred</code> variable. Both the <code class="literal">$uri</code> and <code class="literal">$cred</code> variables are then passed to the <code class="literal">Enter-PSSession</code> cmdlet, which establishes the remote PowerShell session (see <a class="xref" href="61.xhtml#a7.6" title="Figure 7-6. Entering a remote PowerShell session">Figure 7-6</a>).<a id="id395285" class="indexterm"/><a id="id395300" class="indexterm"/></p>
    <div class="example">
      <a id="EX-7-10"/>
      <div class="example-title">Example 7-9. Entering a remote PowerShell session (Console pane)</div>
      <div class="example-contents">
        <pre class="programlisting"><code class="nv">$uri</code> <code class="p">=</code> <code class="nb">Get-AzureWinRMUri</code> <code class="n">-ServiceName</code> <code class="nv">$serviceName</code> <code class="n">-Name</code> <code class="nv">$vmName</code>

<code class="nv">$cred</code> <code class="p">=</code> <code class="nb">Get-Credential</code>

<code class="nb">Enter-PSSession</code> <code class="n">-ConnectionUri</code> <code class="nv">$uri</code> <code class="n">-Credential</code> <code class="nv">$cred</code></pre>
      </div>
    </div>
    <div class="figure">
      <a id="a7.6"/>
      <div class="figure-contents">
        <div class="mediaobject">
          <img src="images-amas_0706.png" alt="Entering a remote PowerShell session"/>
        </div>
      </div>
      <div class="figure-title">Figure 7-6. Entering a remote PowerShell session</div>
    </div>
  </div>
  <div class="sect2" title="Invoking PowerShell Commands">
    <div class="titlepage">
      <div>
        <div>
          <h3 class="title" id="_invoking_powershell_commands">Invoking PowerShell Commands</h3>
        </div>
      </div>
    </div>
    <p><a id="id395445" class="indexterm"/>Using these same techniques, it is easy to execute a PowerShell script remotely on one or more of your virtual machines. Executing commands this way allows you to automate the configuration of roles and features; monitor, download, and install software; update registry settings; or whatever task you can dream up and deliver through PowerShell.</p>
    <p>In <a class="xref" href="61.xhtml#EX-7-11" title="Example 7-10. Executing a script block (Console pane)">Example 7-10</a> I am using the same cmdlets as before—<code class="literal">Get-AzureWinRMUri</code> and <code class="literal">Get-Credential</code>—and instead of starting an interactive PowerShell session, I am just executing a script that installs IIS by using the <code class="literal">Invoke-Command</code> cmdlet (see <a class="xref" href="61.xhtml#b7.6" title="Figure 7-7. Executing a script block to install IIS">Figure 7-7</a>). Combine this code with <code class="literal">Get-AzureVM</code> and you can see how you could easily execute scripts against multiple virtual machines as part of an automation task.</p>
    <div class="example">
      <a id="EX-7-11"/>
      <div class="example-title">Example 7-10. Executing a script block (Console pane)</div>
      <div class="example-contents">
        <pre class="programlisting"><code class="nv">$uri</code> <code class="p">=</code> <code class="nb">Get-AzureWinRMUri</code> <code class="n">-ServiceName</code> <code class="nv">$serviceName</code> <code class="n">-Name</code> <code class="nv">$vmName</code>

<code class="nv">$cred</code> <code class="p">=</code> <code class="nb">Get-Credential</code>

<code class="nb">Invoke-Command</code> <code class="n">-ConnectionUri</code> <code class="nv">$uri</code> <code class="p">`</code>
               <code class="n">-Credential</code> <code class="nv">$cred</code> <code class="p">`</code>
               <code class="n">-ScriptBlock</code> <code class="p">{</code> <code class="n">Install-WindowsFeature</code> <code class="n">-Name</code> <code class="s2">"Web-Server"</code> <code class="p">}</code></pre>
      </div>
    </div>
    <div class="figure">
      <a id="b7.6"/>
      <div class="figure-contents">
        <div class="mediaobject">
          <img src="images-amas_0707.png" alt="Executing a script block to install IIS"/>
        </div>
      </div>
      <div class="figure-title">Figure 7-7. Executing a script block to install IIS</div>
    </div>
    <p>The <code class="literal">Invoke-Command</code> cmdlet can also accept a <code class="literal">-FilePath</code> parameter, which allows you to specify a file path to a local script instead of a script block. You can also pass parameters using either method with the <code class="literal">-ArgumentList</code> parameter.</p>
  </div>
  <div class="sect2" title="Multiple Hops Using Remote PowerShell">
    <div class="titlepage">
      <div>
        <div>
          <h3 class="title" id="_multiple_hops_using_remote_powershell">Multiple Hops Using Remote PowerShell</h3>
        </div>
      </div>
    </div>
    <p><a id="id395688" class="indexterm"/>One common problem most people run into when using PowerShell remotely is the multihop dilemma. A remote PowerShell session allows you to execute commands on the computer to which you are connected. This privilege is not delegated to other computers on the remote network by default. This means that for you to access files from a remote file server or to connect to another service using the credentials you used with your PowerShell session, you will be out of luck without additional configuration steps.</p>
    <p>If you do need the ability to make multiple hops from your PowerShell session, you can enable<a id="id395719" class="indexterm"/> CredSSP on your client machine and on the server running your PowerShell session. For more details on how to enable this and the security ramifications involved, see the following articles: <a class="ulink" href="http://bit.ly/multi-hop_support" target="_top">http://bit.ly/multi-hop_support</a> and <a class="ulink" href="http://bit.ly/CredSSP" target="_top">http://bit.ly/CredSSP</a>. <a id="id395723" class="indexterm"/></p>
  </div>
</div>
  </reader></div></body>
</html>
